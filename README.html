<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="apprendre-%C3%A0-programmer-en-rust--pour-les-nuls">APPRENDRE À PROGRAMMER EN RUST : POUR LES NULS</h1>
<hr>
<h2 id="table-des-mati%C3%A8res">Table des matières</h2>
<!-- TOC -->
<ul>
<li><a href="#apprendre-%C3%A0-programmer-en-rust--pour-les-nuls">APPRENDRE À PROGRAMMER EN RUST : POUR LES NULS</a>
<ul>
<li><a href="#table-des-mati%C3%A8res">Table des matières</a></li>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#pourquoi-choisir-rust-">Pourquoi choisir Rust ?</a>
<ul>
<li><a href="#%C3%A0-qui-sadresse-ce-livre-">À qui s'adresse ce livre ?</a></li>
<li><a href="#comment-utiliser-ce-livre">Comment utiliser ce livre</a></li>
<li><a href="#s%C3%A9curit%C3%A9-de-la-m%C3%A9moire">Sécurité de la mémoire</a></li>
<li><a href="#concurrence-sans-crainte">Concurrence sans crainte</a></li>
<li><a href="#performance">Performance</a></li>
<li><a href="#cas-dutilisation-et-entreprises-qui-utilisent-rust">Cas d'utilisation et entreprises qui utilisent Rust</a></li>
</ul>
</li>
<li><a href="#installation-et-environnement-de-d%C3%A9veloppement">Installation et environnement de développement</a>
<ul>
<li><a href="#installation-de-rust-et-de-cargo-gestionnaire-de-paquets">Installation de Rust et de cargo (gestionnaire de paquets)</a></li>
<li><a href="#configuration-de-l%C3%A9diteur-de-code">Configuration de l'éditeur de code</a></li>
<li><a href="#compilation-et-ex%C3%A9cution-dun-programme-rust-simple">Compilation et exécution d'un programme Rust simple</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#fondamentaux-de-rust">Fondamentaux de Rust</a>
<ul>
<li><a href="#les-bases-de-rust">Les bases de Rust</a>
<ul>
<li><a href="#variables-et-mutabilit%C3%A9">Variables et mutabilité</a></li>
<li><a href="#types-de-donn%C3%A9es-scalars-et-compound-types">Types de données (Scalars et compound types)</a>
<ul>
<li><a href="#les-types-de-donn%C3%A9es-scalaires-comprennent-les-entiers-les-flottants-les-bool%C3%A9ens-et-les-caract%C3%A8res">Les types de données scalaires comprennent les entiers, les flottants, les booléens et les caractères</a></li>
<li><a href="#les-types-de-donn%C3%A9es-compos%C3%A9s-comprennent-les-tuples-les-tableaux-les-cha%C3%AEnes-de-caract%C3%A8res-et-les-pointeurs">Les types de données composés comprennent les tuples, les tableaux, les chaînes de caractères et les pointeurs</a></li>
</ul>
</li>
<li><a href="#fonctions">Fonctions</a></li>
<li><a href="#commentaires">Commentaires</a></li>
<li><a href="#exemples-de-programmes-rust-simples">Exemples de programmes Rust simples</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#contr%C3%B4le-de-flux">Contrôle de flux</a>
<ul>
<li><a href="#structures-de-contr%C3%B4le">Structures de contrôle</a>
<ul>
<li><a href="#if-else-et-else-if"><code>if</code>, <code>else</code> et <code>else if</code></a></li>
<li><a href="#loop"><code>loop</code></a></li>
<li><a href="#while"><code>while</code></a></li>
<li><a href="#for"><code>for</code></a></li>
<li><a href="#match"><code>match</code></a></li>
<li><a href="#break"><code>break</code></a></li>
<li><a href="#continue"><code>continue</code></a></li>
<li><a href="#return"><code>return</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#concepts-avanc%C3%A9s">Concepts avancés</a>
<ul>
<li><a href="#pattern-matching-et-contr%C3%B4le-de-flux">Pattern Matching et Contrôle de Flux</a>
<ul>
<li><a href="#match-1"><code>match</code></a></li>
<li><a href="#comparaison-avec-if-let-et-while-let">Comparaison avec <code>if let</code> et <code>while let</code></a>
<ul>
<li><a href="#if-let"><code>if let</code></a></li>
<li><a href="#while-let"><code>while let</code></a></li>
<li><a href="#if-let-et-while-let-avec-des-%C3%A9num%C3%A9rations"><code>if let</code> et <code>while let</code> avec des énumérations</a></li>
</ul>
</li>
<li><a href="#patterns-exhaustifs-et-le-joker-_">Patterns exhaustifs et le joker <code>_</code></a>
<ul>
<li><a href="#patterns-exhaustifs">Patterns exhaustifs</a></li>
<li><a href="#le-joker-_">Le joker <code>_</code></a></li>
</ul>
</li>
<li><a href="#matching-sur-les-%C3%A9num%C3%A9rations-imbriqu%C3%A9es">Matching sur les énumérations imbriquées</a></li>
<li><a href="#matching-sur-les-valeurs-de-r%C3%A9f%C3%A9rence">Matching sur les valeurs de référence</a></li>
<li><a href="#matching-sur-les-tuples">Matching sur les tuples</a></li>
<li><a href="#matching-sur-les-pointeurs-intelligents">Matching sur les pointeurs intelligents</a></li>
<li><a href="#matching-sur-les-cha%C3%AEnes-de-caract%C3%A8res">Matching sur les chaînes de caractères</a></li>
<li><a href="#guards-dans-les-patterns">Guards dans les patterns</a></li>
</ul>
</li>
<li><a href="#g%C3%A9n%C3%A9riques">Génériques</a>
<ul>
<li><a href="#les-traits">Les traits</a></li>
<li><a href="#les-macros">Les macros</a></li>
</ul>
</li>
<li><a href="#ownership-propri%C3%A9t%C3%A9">Ownership (Propriété)</a>
<ul>
<li><a href="#r%C3%A8gles-de-lownership">Règles de l'ownership</a></li>
<li><a href="#emprunts-et-r%C3%A9f%C3%A9rences">Emprunts et références</a></li>
<li><a href="#slices">Slices</a></li>
<li><a href="#les-cha%C3%AEnes-de-caract%C3%A8res">Les chaînes de caractères</a></li>
</ul>
</li>
<li><a href="#structures-et-%C3%A9num%C3%A9rations--les-types-de-donn%C3%A9es-avanc%C3%A9s">Structures et Énumérations : Les types de données avancés</a>
<ul>
<li><a href="#enum-et-pattern-matching">Enum et pattern matching</a></li>
<li><a href="#d%C3%A9finir-et-utiliser-une-structure">Définir et utiliser une structure</a></li>
<li><a href="#tuples">Tuples</a></li>
<li><a href="#m%C3%A9thode-et-champ-associ%C3%A9">Méthode et champ associé</a></li>
<li><a href="#exemple--gestion-d%C3%A9tats-avec-enum">Exemple : Gestion d'états avec enum</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#gestion-des-erreurs">Gestion des erreurs</a>
<ul>
<li><a href="#result-et-option">Result et Option</a>
<ul>
<li><a href="#resultt-e"><code>Result&lt;T, E&gt;</code></a></li>
<li><a href="#optiont"><code>Option&lt;T&gt;</code></a></li>
<li><a href="#propagation-des-erreurs">Propagation des erreurs</a></li>
<li><a href="#exemple--lecture-dun-fichier-et-gestion-des-erreurs">Exemple : Lecture d'un fichier et gestion des erreurs</a></li>
<li><a href="#gestion-des-erreurs-avec--et-unwrap">Gestion des erreurs avec <code>?</code> et <code>unwrap</code></a>
<ul>
<li><a href="#lop%C3%A9rateur-">L'opérateur <code>?</code></a></li>
<li><a href="#unwrap--est-une-m%C3%A9thode-qui-extrait-la-valeur-r%C3%A9ussie-dun-r%C3%A9sultat-ou-provoque-une-panique-si-une-erreur-se-produit"><code>unwrap</code> : est une méthode qui extrait la valeur réussie d'un résultat ou provoque une panique si une erreur se produit</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#rust-dans-la-pratique">Rust dans la Pratique</a>
<ul>
<li><a href="#collections">Collections</a>
<ul>
<li><a href="#vecteurs-string-et-hashmap">Vecteurs, String et HashMap</a>
<ul>
<li><a href="#vecteurs">Vecteurs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#entr%C3%A9es-utilisateur-et-manipulation-de-cha%C3%AEnes-de-caract%C3%A8res">Entrées utilisateur et Manipulation de Chaînes de Caractères</a>
<ul>
<li><a href="#entr%C3%A9es-utilisateur">Entrées utilisateur</a>
<ul>
<li><a href="#lecture-dentr%C3%A9es-utilisateur-avec-stdio">Lecture d'entrées utilisateur avec <code>std::io</code></a>
<ul>
<li><a href="#lecture-dune-cha%C3%AEne-de-caract%C3%A8res">Lecture d'une chaîne de caractères</a></li>
</ul>
</li>
<li><a href="#exemple--programme-manipulant-des-donn%C3%A9es-utilisateur">Exemple : Programme manipulant des données utilisateur</a></li>
</ul>
</li>
<li><a href="#gestion-de-projets-avec-cargo">Gestion de projets avec Cargo</a>
<ul>
<li><a href="#cr%C3%A9ation-dun-nouveau-projet">Création d'un nouveau projet</a></li>
<li><a href="#d%C3%A9pendances-et-crates">Dépendances et Crates</a></li>
<li><a href="#tests">Tests</a></li>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#exemple--cr%C3%A9ation-dun-projet-avec-d%C3%A9pendances-externes">Exemple : Création d'un projet avec dépendances externes</a></li>
<li><a href="#construction-et-ex%C3%A9cution-du-projet">Construction et Exécution du Projet</a></li>
</ul>
</li>
<li><a href="#programmation-concurrente-et-parall%C3%A9lisme">Programmation concurrente et Parallélisme</a>
<ul>
<li><a href="#threads">Threads</a>
<ul>
<li><a href="#cr%C3%A9ation-de-threads">Création de Threads</a></li>
</ul>
</li>
<li><a href="#canaux-de-communication">Canaux de communication</a>
<ul>
<li><a href="#cr%C3%A9ation-dun-canal">Création d'un canal</a></li>
</ul>
</li>
<li><a href="#mod%C3%A8le-de-m%C3%A9moire-partag%C3%A9e">Modèle de mémoire partagée</a>
<ul>
<li><a href="#exemple--m%C3%A9moire-partag%C3%A9e-avec-mutex">Exemple : Mémoire partagée avec Mutex</a></li>
</ul>
</li>
<li><a href="#exemple--programme-t%C3%A9l%C3%A9chargeant-des-donn%C3%A9es-en-parall%C3%A8le">Exemple : Programme téléchargeant des données en parallèle</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#projets-et-ressources-compl%C3%A9mentaires">Projets et Ressources Complémentaires</a>
<ul>
<li><a href="#cr%C3%A9er-un-projet-en-rust">Créer un projet en Rust</a>
<ul>
<li><a href="#id%C3%A9es-de-projets-pour-appliquer-les-connaissances-acquises">Idées de projets pour appliquer les connaissances acquises</a></li>
<li><a href="#%C3%A9tapes-de-d%C3%A9veloppement-dun-projet">Étapes de développement d'un projet</a></li>
</ul>
</li>
<li><a href="#ressources-compl%C3%A9mentaires-et-communaut%C3%A9">Ressources complémentaires et communauté</a>
<ul>
<li><a href="#livres-et-documentation-en-ligne">Livres et documentation en ligne</a></li>
<li><a href="#forums-groupes-et-conf%C3%A9rences">Forums, groupes et conférences</a></li>
<li><a href="#outils-et-biblioth%C3%A8ques">Outils et bibliothèques</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a>
<ul>
<li><a href="#r%C3%A9vision-et-prochaines-%C3%A9tapes">Révision et prochaines étapes</a>
<ul>
<li><a href="#r%C3%A9capitulatif-des-concepts-cl%C3%A9s">Récapitulatif des concepts clés</a></li>
<li><a href="#prochaines-%C3%A9tapes">Prochaines étapes</a></li>
<li><a href="#conseils-pour-continuer-%C3%A0-apprendre-et-pratiquer">Conseils pour continuer à apprendre et pratiquer</a></li>
<li><a href="#remerciements-et-ressources">Remerciements et ressources</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="introduction">Introduction</h2>
<p>Ce livre est une introduction à la programmation en Rust pour les débutants. Il est conçu pour les personnes qui n'ont aucune expérience en programmation, mais qui veulent apprendre à programmer. Le livre est divisé en plusieurs chapitres, chacun couvrant un aspect différent de la programmation en Rust. Chaque chapitre contient des exemples de code, des exercices et des quiz pour vous aider à apprendre.</p>
<h2 id="pourquoi-choisir-rust">Pourquoi choisir Rust ?</h2>
<p>Rust est un langage de programmation moderne conçu pour être sûr, rapide et concurrent. Il est idéal pour les applications qui nécessitent une performance élevée et une sécurité de la mémoire. Rust est également un langage polyvalent qui peut être utilisé pour une variété de tâches, allant de la programmation système à la programmation web.</p>
<h3 id="%C3%A0-qui-sadresse-ce-livre">À qui s'adresse ce livre ?</h3>
<p>Ce livre s'adresse à toute personne intéressée par la programmation en Rust, qu'elle soit débutante ou expérimentée. Il est conçu pour les personnes qui veulent apprendre à programmer en Rust, mais qui n'ont aucune expérience en programmation. Le livre couvre les bases de la programmation en Rust, y compris les types de données, les fonctions, les boucles, les structures de contrôle, la gestion de la mémoire, la programmation concurrente et la gestion des erreurs.</p>
<h3 id="comment-utiliser-ce-livre">Comment utiliser ce livre</h3>
<p>Ce livre est conçu pour être utilisé comme un guide d'apprentissage autonome. Chaque chapitre couvre un aspect différent de la programmation en Rust, et contient des exemples de code, des exercices et des quiz pour vous aider à apprendre. Vous pouvez lire le livre de manière linéaire, en suivant les chapitres dans l'ordre, ou vous pouvez sauter directement aux chapitres qui vous intéressent.</p>
<h3 id="s%C3%A9curit%C3%A9-de-la-m%C3%A9moire">Sécurité de la mémoire</h3>
<p>Rust est conçu pour être sûr, ce qui signifie qu'il est difficile de faire des erreurs de programmation qui pourraient causer des problèmes de sécurité ou de stabilité. Rust utilise un système de gestion de la mémoire innovant qui garantit que les programmes ne peuvent pas accéder à la mémoire de manière incorrecte ou dangereuse.
Rust est un langage de programmation moderne conçu pour être sûr, rapide et concurrent. Il est idéal pour les applications qui nécessitent une performance élevée et une sécurité de la mémoire. Rust est également un langage polyvalent qui peut être utilisé pour une variété de tâches, allant de la programmation système à la programmation web.</p>
<h3 id="concurrence-sans-crainte">Concurrence sans crainte</h3>
<p>Rust est conçu pour faciliter la programmation concurrente, ce qui signifie que vous pouvez écrire des programmes qui exécutent plusieurs tâches en parallèle sans craindre les problèmes de concurrence. Rust utilise un modèle de mémoire partagée innovant qui garantit que les programmes concurrents sont sûrs et fiables.
La concurrence est un aspect important de la programmation moderne, car de nombreux programmes doivent exécuter plusieurs tâches en parallèle pour être efficaces. Rust est conçu pour faciliter la programmation concurrente, ce qui signifie que vous pouvez écrire des programmes qui exécutent plusieurs tâches en parallèle sans craindre les problèmes de concurrence.</p>
<h3 id="performance">Performance</h3>
<p>Rust est conçu pour être rapide, ce qui signifie qu'il peut exécuter des programmes à une vitesse élevée. Rust utilise un système de compilation avancé qui optimise automatiquement le code pour obtenir les meilleures performances possibles. Cela signifie que vous pouvez écrire des programmes en Rust qui sont aussi rapides que des programmes écrits dans des langages de programmation bas niveau comme le C ou le C++.</p>
<h3 id="cas-dutilisation-et-entreprises-qui-utilisent-rust">Cas d'utilisation et entreprises qui utilisent Rust</h3>
<p>Rust est utilisé par de nombreuses entreprises pour développer des logiciels critiques, y compris des systèmes d'exploitation, des navigateurs web, des bases de données et des outils de développement. Rust est également utilisé par de nombreuses startups pour développer des applications web, des jeux vidéo et des logiciels de sécurité. Rust est un langage polyvalent qui peut être utilisé pour une variété de tâches, allant de la programmation système à la programmation web.</p>
<h2 id="installation-et-environnement-de-d%C3%A9veloppement">Installation et environnement de développement</h2>
<p>Avant de commencer à programmer en Rust, vous devez installer Rust selon votre système d'exploitation et configurer votre environnement de développement. Dans ce chapitre, nous allons vous montrer comment installer <a href="https://www.rust-lang.org/fr/tools/install">Rust</a> et <code>cargo</code> (le gestionnaire de paquets de Rust), configurer votre éditeur de code et compiler et exécuter un programme Rust simple.
La documentation officielle de Rust est également une ressource utile pour l'installation et la configuration de l'environnement de développement.</p>
<h3 id="installation-de-rust-et-de-cargo-gestionnaire-de-paquets">Installation de Rust et de cargo (gestionnaire de paquets)</h3>
<p>Pour installer Rust et cargo, vous pouvez utiliser le <a href="https://www.rust-lang.org/fr/tools/install">site officiel de Rust</a>. Vous y trouverez des instructions détaillées pour installer Rust sur Windows, macOS et Linux. Une fois que vous avez installé Rust, vous aurez accès à la commande <code>rustc</code> (le compilateur Rust) et à la commande <code>cargo</code> (le gestionnaire de paquets de Rust).</p>
<h3 id="configuration-de-l%C3%A9diteur-de-code">Configuration de l'éditeur de code</h3>
<p>Rust est pris en charge par de nombreux éditeurs de code, y compris Visual Studio Code, IntelliJ IDEA, RustRover, Sublime Text, Vim et Emacs. Vous pouvez trouver des extensions pour ces éditeurs qui ajoutent des fonctionnalités de Rust, comme la coloration syntaxique, l'auto-complétion, le débogage et la gestion de projet. Vous pouvez également utiliser un éditeur de code en ligne comme <a href="https://repl.it/languages/rust">Repl.it</a> pour écrire et exécuter des programmes Rust sans installer quoi que ce soit sur votre ordinateur.</p>
<h3 id="compilation-et-ex%C3%A9cution-dun-programme-rust-simple">Compilation et exécution d'un programme Rust simple</h3>
<p>Pour créer un nouveau projet Rust, vous pouvez utiliser la commande : <code>cargo new nom_du_projet</code>, puis la commande <code>cargo run</code> pour compiler et exécuter le programme. Par exemple, voici un programme Rust simple qui affiche &quot;Hello, world!&quot; à l'écran :</p>
<pre class="hljs"><code><div>cargo new hello_world
<span class="hljs-built_in">cd</span> hello_world
</div></code></pre>
<p>Cette commande crée un nouveau projet Rust appelé <code>hello_world</code>. Ensuite, vous pouvez ouvrir le fichier <code>src/main.rs</code> dans votre éditeur de code et y écrire le code suivant :</p>
<p>Voyons la structure de ce programme de notre projet <code>hello_world</code> :</p>
<pre class="hljs"><code><div>hello_world/
│
├── Cargo.toml
│
└── src/
    └── main.rs
</div></code></pre>
<p><strong>Détails des composants</strong></p>
<ul>
<li><strong><code>Cargo.toml</code></strong> : Ce fichier contient les métadonnées de votre projet et les dépendances. Pour un projet <code>hello_world</code>, le contenu de <code>Cargo.toml</code> pourrait ressembler à cela :</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-section">[package]</span>
<span class="hljs-attr">name</span> = <span class="hljs-string">"hello_world"</span>
<span class="hljs-attr">version</span> = <span class="hljs-string">"0.1.0"</span>
<span class="hljs-attr">edition</span> = <span class="hljs-string">"2021"</span>

<span class="hljs-comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span>

<span class="hljs-section">[dependencies]</span>
</div></code></pre>
<ul>
<li>
<p><strong>src/</strong> : Ce dossier contient le code source de votre projet.</p>
</li>
<li>
<p><strong>main.rs</strong> : C'est le point d'entrée de votre application. Pour un simple &quot;Hello, world!&quot;, le contenu de main.rs serait :</p>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Hello, world!"</span>);
}
</div></code></pre>
<p>Étudions ce code en détail :</p>
<ul>
<li><code>fn main() { ... }</code> : C'est la fonction principale de votre programme. Tous les programmes Rust commencent par une fonction <code>main</code>. Le code entre les accolades <code>{ ... }</code> est le corps de la fonction <code>main</code>.</li>
<li><code>println!(&quot;Hello, world!&quot;);</code> : C'est une macro Rust qui affiche du texte à l'écran. Dans ce cas, la macro <code>println!</code> affiche &quot;Hello, world!&quot; à l'écran.</li>
</ul>
<p>Pour compiler et exécuter ce programme, vous pouvez utiliser la commande <code>cargo run</code> dans le terminal :</p>
<pre class="hljs"><code><div>cargo run
</div></code></pre>
<p>Dans le terminal, vous verrez la sortie suivante :</p>
<pre class="hljs"><code><div>   Compiling hello_world v0.1.0 (file:///path/to/your/project/hello_world)
    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.34s
     Running `target/debug/hello_world`
Hello, world!
</div></code></pre>
<p>Félicitations ! Vous venez de compiler et d'exécuter votre premier programme Rust. Vous êtes maintenant prêt à commencer à apprendre les bases de la programmation en Rust.</p>
<h1 id="fondamentaux-de-rust">Fondamentaux de Rust</h1>
<p>Dans ce chapitre, nous allons couvrir les bases de la programmation en Rust. Nous allons commencer par les variables et la mutabilité, puis nous aborderons les types de données, les fonctions, les commentaires et les exemples de programmes Rust simples.</p>
<h2 id="les-bases-de-rust">Les bases de Rust</h2>
<p>Les bases de Rust comprennent les variables et la mutabilité, les types de données, les fonctions et les commentaires. Ces concepts sont essentiels pour comprendre la programmation en Rust.</p>
<h3 id="variables-et-mutabilit%C3%A9">Variables et mutabilité</h3>
<p>En Rust, les variables sont créées en utilisant le mot-clé <code>let</code>. Par défaut, les variables sont immuables, ce qui signifie qu'une fois qu'elles ont une valeur, cette valeur ne peut pas être modifiée. Voici un exemple de déclaration de variable immuable en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x);
}
</div></code></pre>
<p>Dans cet exemple, <code>x</code> est une variable immuable qui contient la valeur <code>5</code>. Si vous essayez de modifier la valeur de <code>x</code>, vous obtiendrez une erreur de compilation.</p>
<p>Par exemple, le code suivant générera une erreur de compilation :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
    x = <span class="hljs-number">10</span>; <span class="hljs-comment">// Erreur : tentative de modification d'une variable immuable</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x);
}
</div></code></pre>
<p>Pour rendre une variable mutable, vous pouvez utiliser le mot-clé <code>mut</code> lors de sa déclaration. Voici un exemple de déclaration de variable mutable en Rust :</p>
<p>La <code>mutabilité</code> est une caractéristique importante de Rust qui garantit que les programmes sont sûrs et fiables. En Rust, les variables sont immuables par défaut, ce qui signifie qu'une fois qu'elles ont une valeur, cette valeur ne peut pas être modifiée. Cela garantit que les programmes ne peuvent pas accéder à la mémoire de manière incorrecte ou dangereuse.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = <span class="hljs-number">5</span>;
    x = <span class="hljs-number">10</span>; <span class="hljs-comment">// Pas d'erreur : x est une variable mutable</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x);
}
</div></code></pre>
<p>Dans cet exemple, <code>x</code> est une variable mutable qui contient la valeur <code>5</code>. Vous pouvez modifier la valeur de <code>x</code> en utilisant l'opérateur d'affectation <code>=</code>. Le code ci-dessus affichera &quot;La valeur de x est : 10&quot; à l'écran.</p>
<h3 id="types-de-donn%C3%A9es-scalars-et-compound-types">Types de données (Scalars et compound types)</h3>
<p>Rust prend en charge plusieurs types de données, y compris les types scalaires (entiers, flottants, booléens, caractères) et les types composés (tuples, tableaux, chaînes de caractères, pointeurs). Voici quelques exemples de types de données en Rust :</p>
<h4 id="les-types-de-donn%C3%A9es-scalaires-comprennent-les-entiers-les-flottants-les-bool%C3%A9ens-et-les-caract%C3%A8res">Les types de données scalaires comprennent les entiers, les flottants, les booléens et les caractères</h4>
<p>Les types de données scalaires sont des types de données qui représentent une seule valeur. Les types de données composés sont des types de données qui représentent plusieurs valeurs regroupées. Les types de données scalaires comprennent les entiers, les flottants, les booléens et les caractères.</p>
<ul>
<li>Entiers : <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code> :
<ul>
<li>Les entiers signés (<code>i</code>) peuvent stocker des nombres négatifs et positifs.</li>
<li>Les entiers non signés (<code>u</code>) ne peuvent stocker que des nombres positifs.</li>
<li>Le nombre après le <code>i</code> ou le <code>u</code> indique la taille de l'entier en bits (par exemple, <code>i8</code> est un entier signé de 8 bits).</li>
<li>Exemple : <code>let x: i32 = 5;</code> (déclare une variable <code>x</code> de type <code>i32</code> avec la valeur <code>5</code> avec une taille de 32 bits ).</li>
</ul>
</li>
</ul>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">i32</span> = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> y: <span class="hljs-built_in">i8</span> = -<span class="hljs-number">10</span>;
    <span class="hljs-keyword">let</span> z: <span class="hljs-built_in">u8</span> = <span class="hljs-number">10</span>;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// La valeur de x est : 5</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de y est : {}"</span>, y); <span class="hljs-comment">// La valeur de y est : -10</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de z est : {}"</span>, z); <span class="hljs-comment">// La valeur de z est : 10</span>
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">u32</span> = -<span class="hljs-number">5</span>; <span class="hljs-comment">// Un entier non signé de 32 bits avec une valeur négative (erreur de compilation)</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// Erreur : tentative de stocker un nombre négatif dans un entier non signé</span>
}
</div></code></pre>
<p>Pour comprendre la taille des types de données, vous pouvez consulter la documentation officielle de Rust ou avoir la notion du code binaire sachant que 1 octet = 8 bits.</p>
<ul>
<li>Flottants : <code>f32</code>, <code>f64</code> :
<ul>
<li>Les flottants sont utilisés pour stocker des nombres à virgule flottante ou réels.</li>
<li><code>f32</code> est un flottant de 32 bits et <code>f64</code> est un flottant de 64 bits.</li>
<li>Exemple : <code>let x: f64 = 5.0;</code> (déclare une variable <code>x</code> de type <code>f64</code> avec la valeur <code>5.0</code>).</li>
</ul>
</li>
</ul>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">f64</span> = <span class="hljs-number">5.5</span>; <span class="hljs-comment">// Un flottant de 64 bits</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// La valeur de x est : 5.5</span>
}
</div></code></pre>
<ul>
<li>Booléens : <code>bool</code> :
<ul>
<li>Les booléens sont utilisés pour stocker des valeurs de vérité (vrai ou faux). - Exemple : <code>let x: bool = true;</code> (déclare une variable <code>x</code> de type <code>bool</code> avec la valeur <code>true</code>).
Exemple :</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">let</span> y: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">false</span>;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// La valeur de x est : true</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de y est : {}"</span>, y); <span class="hljs-comment">// La valeur de y est : false</span>
}
</div></code></pre>
<ul>
<li>Caractères : <code>char</code> :
<ul>
<li>Les caractères sont utilisés pour stocker des caractères Unicode. Ce qui signifie que Rust prend en charge les caractères de toutes les langues et les symboles. Un seul caractère Unicode est stocké dans un type <code>char</code>.</li>
<li>Exemple : <code>let x: char = 'a';</code> (déclare une variable <code>x</code> de type <code>char</code> avec la valeur <code>'a'</code>).
Exemple :</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">char</span> = <span class="hljs-string">'a'</span>;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// La valeur de x est : a</span>
}
</div></code></pre>
<h4 id="les-types-de-donn%C3%A9es-compos%C3%A9s-comprennent-les-tuples-les-tableaux-les-cha%C3%AEnes-de-caract%C3%A8res-et-les-pointeurs">Les types de données composés comprennent les tuples, les tableaux, les chaînes de caractères et les pointeurs</h4>
<p>Les types de données composés sont des types de données qui représentent plusieurs valeurs regroupées. Les types de données composés comprennent les tuples, les tableaux, les chaînes de caractères et les pointeurs.</p>
<ul>
<li>Tuples :
<ul>
<li>Les tuples sont utilisés pour stocker plusieurs valeurs de types différents. Un tuple est déclaré en écrivant les valeurs entre parenthèses et en les séparant par des virgules.</li>
<li>Exemple : <code>let x: (i32, f64, bool) = (5, 5.5, true);</code> (déclare une variable <code>x</code> de type tuple <code>(i32, f64, bool)</code> avec les valeurs <code>5</code>, <code>5.5</code> et <code>true</code>).</li>
<li>Pour accéder aux valeurs d'un tuple, vous pouvez utiliser la notation de point <code>.</code> suivie de l'index de la valeur dans le tuple (en commençant par <code>0</code>).</li>
</ul>
</li>
</ul>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: (<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">f64</span>, <span class="hljs-built_in">bool</span>) = (<span class="hljs-number">5</span>, <span class="hljs-number">5.5</span>, <span class="hljs-literal">true</span>);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La première valeur de x est : {}"</span>, x.<span class="hljs-number">0</span>); <span class="hljs-comment">// La première valeur de x est : 5</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La deuxième valeur de x est : {}"</span>, x.<span class="hljs-number">1</span>); <span class="hljs-comment">// La deuxième valeur de x est : 5.5</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La troisième valeur de x est : {}"</span>, x.<span class="hljs-number">2</span>); <span class="hljs-comment">// La troisième valeur de x est : true</span>
}
</div></code></pre>
<p>Cette manière de déclarer les tuples est appelée <code>déstructuration</code> des tuples.</p>
<ul>
<li>Tableaux :
<ul>
<li>Les tableaux sont utilisés pour stocker plusieurs valeurs de même type. Un tableau est déclaré en écrivant les valeurs entre crochets et en les séparant par des virgules.</li>
<li>Exemple : <code>let x: [i32; 5] = [1, 2, 3, 4, 5];</code> (déclare une variable <code>x</code> de type tableau <code>[i32; 5]</code> avec les valeurs <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code> et <code>5</code>).</li>
<li>Pour accéder aux valeurs d'un tableau, vous pouvez utiliser la notation de crochets <code>[]</code> suivie de l'index de la valeur dans le tableau (en commençant par <code>0</code>).</li>
</ul>
</li>
</ul>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: [<span class="hljs-built_in">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Un tableau de 5 entiers de 32 bits</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La première valeur de x est : {}"</span>, x[<span class="hljs-number">0</span>]); <span class="hljs-comment">// La première valeur de x est : 1</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La deuxième valeur de x est : {}"</span>, x[<span class="hljs-number">1</span>]); <span class="hljs-comment">// La deuxième valeur de x est : 2</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La troisième valeur de x est : {}"</span>, x[<span class="hljs-number">2</span>]); <span class="hljs-comment">// La troisième valeur de x est : 3</span>
}
</div></code></pre>
<p>Voyons en détail cette ligne de code : <code>let x: [i32; 5] = [1, 2, 3, 4, 5];</code></p>
<ul>
<li>
<p><code>let x</code> : déclare une variable <code>x</code>.</p>
</li>
<li>
<p><code>: [i32; 5]</code> : indique que <code>x</code> est un tableau de 5 entiers de 32 bits.</p>
</li>
<li>
<p><code>= [1, 2, 3, 4, 5]</code> : initialise <code>x</code> avec les valeurs <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code> et <code>5</code>.</p>
</li>
<li>
<p><code>x[0]</code> : accède à la première valeur de <code>x</code> (qui est <code>1</code>).</p>
</li>
<li>
<p><code>x[1]</code> : accède à la deuxième valeur de <code>x</code> (qui est <code>2</code>).</p>
</li>
<li>
<p><code>x[2]</code> : accède à la troisième valeur de <code>x</code> (qui est <code>3</code>).</p>
</li>
<li>
<p><code>x[3]</code> : accède à la quatrième valeur de <code>x</code> (qui est <code>4</code>).</p>
</li>
<li>
<p><code>x[4]</code> : accède à la cinquième valeur de <code>x</code> (qui est <code>5</code>).</p>
</li>
<li>
<p><code>x[5]</code> : accède à la sixième valeur de <code>x</code> (qui est <code>erreur de compilation</code>).</p>
</li>
<li>
<p>Chaînes de caractères : littérales (<code>&amp;str</code>) et dynamiques (<code>String</code>) :
Les chaînes de caractères sont utilisées pour stocker du texte. En Rust, les chaînes de caractères sont de deux types : les chaînes de caractères littérales (<code>&amp;str</code>) et les chaînes de caractères dynamiques (<code>String</code>).</p>
</li>
</ul>
<p><strong>Chaînes de caractères littérales (<code>&amp;str</code>)</strong> :</p>
<p>Les chaînes de caractères littérales (<code>&amp;str</code>) sont des chaînes de caractères statiques qui sont stockées dans le programme lui-même. - Exemple : <code>let x: &amp;str = &quot;Hello, world!&quot;;</code> (déclare une variable <code>x</code> de type chaîne de caractères littérale <code>&amp;str</code> avec la valeur <code>&quot;Hello, world!&quot;</code>).</p>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: &amp;<span class="hljs-built_in">str</span> = <span class="hljs-string">"Hello, world!"</span>; <span class="hljs-comment">// Une chaîne de caractères littérale</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// La valeur de x est : Hello, world!</span>
}
</div></code></pre>
<p><strong>Chaînes de caractères dynamiques (<code>String</code>)</strong> :</p>
<p>Les chaînes de caractères dynamiques (<code>String</code>) sont des chaînes de caractères qui peuvent être modifiées à l'exécution. - Exemple : <code>let x: String = String::from(&quot;Hello, world!&quot;);</code> (déclare une variable <code>x</code> de type chaîne de caractères dynamique <code>String</code> avec la valeur <code>&quot;Hello, world!&quot;</code>).</p>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">String</span> = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Hello, world!"</span>); <span class="hljs-comment">// Une chaîne de caractères dynamique</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// La valeur de x est : Hello, world!</span>
}
</div></code></pre>
<p>Voyons en détail cette ligne de code : <code>let x: String = String::from(&quot;Hello, world!&quot;);</code></p>
<ul>
<li><code>let x</code> : déclare une variable <code>x</code> de type <code>String</code>.:</li>
<li><code>= String::from(&quot;Hello, world!&quot;)</code> : initialise <code>x</code> avec la valeur <code>&quot;Hello, world!&quot;</code>.</li>
</ul>
<p><code>String::from()</code> est une fonction associée au type String en Rust, utilisée pour créer une nouvelle instance de String à partir d'une chaîne de caractères littérale. En Rust, les chaînes de caractères littérales, spécifiées avec des guillemets doubles (comme <code>&quot;hello&quot;</code>), sont de type <code>&amp;str</code>. Le type &amp;str représente une vue immuable sur une chaîne de caractères stockée quelque part en mémoire (généralement dans le segment de données du programme, donc immuable et de durée de vie statique). En revanche, le type String est une chaîne de caractères allouée sur le tas, modifiable et de taille dynamique.</p>
<p>La nécessité de <code>String::from()</code> découle de ces différences. Lorsque vous avez besoin d'une chaîne de caractères que vous pouvez modifier ou dont la taille peut changer, vous utilisez un String plutôt qu'un <code>&amp;str</code>.</p>
<p>Exemple, pour convertir un <code>&amp;str</code> en <code>String</code>, vous pouvez utiliser <code>String::from()</code> comme suit :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: &amp;<span class="hljs-built_in">str</span> = <span class="hljs-string">"Hello, world!"</span>; <span class="hljs-comment">// Une chaîne de caractères littérale</span>
    <span class="hljs-keyword">let</span> y: <span class="hljs-built_in">String</span> = <span class="hljs-built_in">String</span>::from(x); <span class="hljs-comment">// Convertit x en une chaîne de caractères dynamique</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de y est : {}"</span>, y); <span class="hljs-comment">// La valeur de y est : Hello, world!</span>
}
</div></code></pre>
<p>Dans cet exemple : <code>let y: String = String::from(x);</code> convertit la chaîne de caractères littérale <code>x</code> en une chaîne de caractères dynamique <code>y</code>.</p>
<ul>
<li>Pointeurs :
<ul>
<li>Les pointeurs sont utilisés pour stocker l'adresse mémoire d'une valeur. En Rust, les pointeurs sont de deux types : les références (<code>&amp;</code>) et les pointeurs intelligents (<code>Box</code>, <code>Rc</code>, <code>Arc</code>, etc.).</li>
<li>Les références (<code>&amp;</code>) sont des pointeurs qui permettent d'accéder à une valeur sans la posséder. Les références sont utilisées pour éviter la copie de valeurs et pour garantir la sécurité de la mémoire.</li>
<li>Les pointeurs intelligents (<code>Box</code>, <code>Rc</code>, <code>Arc</code>, etc.) sont des pointeurs qui permettent de posséder une valeur et de la partager entre plusieurs propriétaires. Les pointeurs intelligents sont utilisés pour gérer la mémoire de manière dynamique et pour garantir la sécurité de la mémoire.</li>
</ul>
</li>
</ul>
<p><strong>Les pointeurs : les références (<code>&amp;</code>)</strong></p>
<p>Les références (<code>&amp;</code>) sont des pointeurs qui permettent d'accéder à une valeur sans la posséder. Les références sont utilisées pour éviter la copie de valeurs et pour garantir la sécurité de la mémoire.</p>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">i32</span> = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> y: &amp;<span class="hljs-built_in">i32</span> = &amp;x; <span class="hljs-comment">// Une référence à x</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// La valeur de x est : 5</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de y est : {}"</span>, y); <span class="hljs-comment">// La valeur de y est : 5</span>
}
</div></code></pre>
<p>Dans cet exemple, <code>let y: &amp;i32 = &amp;x;</code> crée une référence <code>y</code> à la valeur <code>x</code>. La référence <code>y</code> permet d'accéder à la valeur <code>x</code> sans la posséder. Cela signifie que <code>y</code> ne possède pas la valeur <code>x</code>, mais qu'il peut y accéder.</p>
<p><strong>Les pointeurs intelligents (<code>Box</code>, <code>Rc</code>, <code>Arc</code>, <code>RefCell</code>, <code>Mutex</code>, <code>Cow</code> )</strong></p>
<p>En Rust, les pointeurs intelligents sont des types de données qui non seulement agissent comme des pointeurs, mais offrent également des fonctionnalités supplémentaires, telles que la gestion de la mémoire ou la sécurité à l'exécution. Voici une liste des pointeurs intelligents les plus couramment utilisés en Rust :</p>
<p>1- <strong>Box<T></strong> : Le type Box permet d'allouer des données sur le tas plutôt que sur la pile. Un Box pointe vers des données allouées dans le tas et détruit ces données lorsque le Box sort de la portée, ce qui permet de gérer la mémoire automatiquement et en toute sécurité. Box est souvent utilisé pour :</p>
<p><code>Box&lt;T&gt;</code> : <code>T</code> est un type de données quelconque. Box est utilisé pour :</p>
<ul>
<li>Créer des types récursifs.</li>
<li>Posséder des données de taille inconnue à la compilation.</li>
<li>Transférer la propriété des données sans faire une copie.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">Box</span>&lt;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-built_in">Box</span>::new(<span class="hljs-number">5</span>); <span class="hljs-comment">// Un pointeur intelligent Box à un entier de 32 bits</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// La valeur de x est : 5</span>
}
</div></code></pre>
<p>Détaillons ce code : <code>let x: Box&lt;i32&gt; = Box::new(5);</code></p>
<ul>
<li><code>let x</code> : déclare une variable <code>x</code> de type <code>Box&lt;i32&gt;</code> avec une taille de 32 bits.</li>
<li><code>= Box::new(5)</code> : initialise <code>x</code> avec la valeur <code>5</code>.</li>
<li><code>Box::new()</code> : crée une nouvelle instance de Box à partir de la valeur <code>5</code>.</li>
</ul>
<p>2- <strong>Rc<T></strong> : Le type <code>Rc</code> fournit un comptage de références immuables, permettant à plusieurs parties du code de &quot;posséder&quot; des données. Lorsque le dernier Rc pointant vers des données est détruit, les données sont également détruites. Rc est utilisé pour :</p>
<p><code>Rc&lt;T&gt;</code> veut dire &quot;Reference Count&quot; (comptage de références). Rc est utilisé pour :</p>
<ul>
<li>Partager des données immuables entre plusieurs parties d'un programme.</li>
<li>Utilisé uniquement dans des scénarios à thread unique.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: Rc&lt;<span class="hljs-built_in">i32</span>&gt; = Rc::new(<span class="hljs-number">5</span>); <span class="hljs-comment">// Un pointeur intelligent Rc à un entier de 32 bits</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// La valeur de x est : 5</span>
}
</div></code></pre>
<p>Détaillons ce code : <code>let x: Rc&lt;i32&gt; = Rc::new(5);</code></p>
<ul>
<li><code>let x</code> : déclare une variable <code>x</code> de type <code>Rc&lt;i32&gt;</code> avec une taille de 32 bits.</li>
<li><code>= Rc::new(5)</code> : initialise <code>x</code> avec la valeur <code>5</code>.</li>
<li><code>Rc::new()</code> : crée une nouvelle instance de Rc à partir de la valeur <code>5</code>.</li>
</ul>
<p>3- <strong>Arc<T></strong> : Similaire à Rc, mais Arc est sûr à utiliser dans des contextes multithread grâce à un comptage de références atomique (d'où le nom &quot;Atomic Reference Count&quot;). Arc est utilisé pour :</p>
<p><code>Arc&lt;T&gt;</code> veut dire &quot;Atomic Reference Count&quot; (comptage de références atomique). Arc est utilisé pour :</p>
<ul>
<li>Partager des données immuables entre plusieurs <code>threads</code> (fils d'exécution).</li>
<li>Assurer que les données restent en vie tant qu'au moins un pointeur y accède, dans un environnement multithread.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: Arc&lt;<span class="hljs-built_in">i32</span>&gt; = Arc::new(<span class="hljs-number">5</span>); <span class="hljs-comment">// Un pointeur intelligent Arc à un entier de 32 bits</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// La valeur de x est : 5</span>
}
</div></code></pre>
<p>Détaillons ce code : <code>let x: Arc&lt;i32&gt; = Arc::new(5);</code></p>
<ul>
<li><code>let x</code> : déclare une variable <code>x</code> de type <code>Arc&lt;i32&gt;</code> avec une taille de 32 bits.</li>
<li><code>= Arc::new(5)</code> : initialise <code>x</code> avec la valeur <code>5</code>.</li>
<li><code>Arc::new()</code> : crée une nouvelle instance de Arc à partir de la valeur <code>5</code>.</li>
</ul>
<p>4- <strong>RefCell<T></strong> : Fournit une mutabilité intérieure, permettant de modifier les données même lorsque l'instance RefCell est immuable. RefCell suit les emprunts à l'exécution, paniquant si les règles d'emprunt sont violées. <code>RefCell</code> est souvent utilisé pour :</p>
<ul>
<li>Contourner les règles d'emprunt statiques de Rust lorsque vous savez que le code respectera les règles d'emprunt à l'exécution.</li>
<li>Modifier des données partagées entre différentes parties d'un programme sans recourir à la mutabilité globale.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: RefCell&lt;<span class="hljs-built_in">i32</span>&gt; = RefCell::new(<span class="hljs-number">5</span>); <span class="hljs-comment">// Un pointeur intelligent RefCell à un entier de 32 bits</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// La valeur de x est : 5</span>
}
</div></code></pre>
<p>Détaillons ce code : <code>let x: RefCell&lt;i32&gt; = RefCell::new(5);</code></p>
<ul>
<li><code>let x</code> : déclare une variable <code>x</code> de type <code>RefCell&lt;i32&gt;</code> avec une taille de 32 bits.</li>
<li><code>= RefCell::new(5)</code> : initialise <code>x</code> avec la valeur <code>5</code>.</li>
<li><code>x.borrow_mut()</code> : permet de modifier la valeur de <code>x</code> en utilisant la méthode <code>borrow_mut()</code>.</li>
</ul>
<p>5- <strong>Mutex<T></strong> : Un type de synchronisation qui permet de protéger les données avec un accès exclusif dans un contexte multithread. Mutex est similaire à Arc, mais il ajoute un verrouillage pour s'assurer qu'un seul thread peut accéder aux données à la fois. Mutex est utilisé pour :</p>
<p><code>Mutex&lt;T&gt;</code> veut dire &quot;Mutual Exclusion&quot; (exclusion mutuelle). Mutex est utilisé pour :</p>
<ul>
<li>Protéger des données partagées entre threads.</li>
<li>Assurer qu'un seul thread à la fois peut modifier les données partagées.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: Mutex&lt;<span class="hljs-built_in">i32</span>&gt; = Mutex::new(<span class="hljs-number">5</span>); <span class="hljs-comment">// Un pointeur intelligent Mutex à un entier de 32 bits</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// La valeur de x est : 5</span>
}
</div></code></pre>
<p>Détaillons ce code : <code>let x: Mutex&lt;i32&gt; = Mutex::new(5);</code></p>
<ul>
<li><code>let x</code> : déclare une variable <code>x</code> de type <code>Mutex&lt;i32&gt;</code> avec une taille de 32 bits.</li>
<li><code>= Mutex::new(5)</code> : initialise <code>x</code> avec la valeur <code>5</code>.</li>
<li><code>Mutex::new()</code> : crée une nouvelle instance de Mutex à partir de la valeur <code>5</code>.</li>
</ul>
<p>6- <strong>Cow<T></strong> : Clone On Write (COW) est un type d'énumération qui peut encapsuler soit une référence immuable vers des données (&amp;T), soit une version possédée (T) des données. Cow permet une flexibilité entre performance et propriété des données, clonant les données uniquement si une modification est nécessaire. Cow est utilisé pour :</p>
<ul>
<li>Optimiser les cas où des données pourraient être modifiées, mais sont souvent lues sans modification.</li>
<li>Réduire les coûts de clonage en ne clonant que lorsque c'est absolument nécessaire.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: Cow&lt;<span class="hljs-built_in">i32</span>&gt; = Cow::Borrowed(&amp;<span class="hljs-number">5</span>); <span class="hljs-comment">// Un pointeur intelligent Cow à un entier de 32 bits</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// La valeur de x est : 5</span>
}
</div></code></pre>
<p>Détaillons ce code : <code>let x: Cow&lt;i32&gt; = Cow::Borrowed(&amp;5);</code></p>
<ul>
<li><code>let x</code> : déclare une variable <code>x</code> de type <code>Cow&lt;i32&gt;</code> avec une taille de 32 bits.</li>
<li><code>= Cow::Borrowed(&amp;5)</code> : initialise <code>x</code> avec la valeur <code>5</code>.</li>
<li><code>Cow::Borrowed()</code> : crée une nouvelle instance de Cow à partir de la valeur <code>5</code>.</li>
</ul>
<p>Détaillons ces types de pointeurs intelligents :</p>
<ul>
<li>
<p><strong>Box<T></strong> : Le type Box permet d'allouer des données sur le tas plutôt que sur la pile. Un Box pointe vers des données allouées dans le tas et détruit ces données lorsque le Box sort de la portée, ce qui permet de gérer la mémoire automatiquement et en toute sécurité. Box est souvent utilisé pour :</p>
<ul>
<li>Créer des types récursifs.</li>
<li>Posséder des données de taille inconnue à la compilation.</li>
<li>Transférer la propriété des données sans faire une copie.</li>
</ul>
</li>
<li>
<p><strong>Rc<T></strong> : Le type <code>Rc</code> fournit un comptage de références immuables, permettant à plusieurs parties du code de &quot;posséder&quot; des données. Lorsque le dernier Rc pointant vers des données est détruit, les données sont également détruites. Rc est utilisé pour :</p>
<ul>
<li>Partager des données immuables entre plusieurs parties d'un programme.</li>
<li>Utilisé uniquement dans des scénarios à thread unique.</li>
</ul>
</li>
<li>
<p><strong>Arc<T></strong> : Similaire à Rc, mais Arc est sûr à utiliser dans des contextes multithread grâce à un comptage de références atomique (d'où le nom &quot;Atomic Reference Count&quot;). Arc est utilisé pour :</p>
<ul>
<li>Partager des données immuables entre plusieurs <code>threads</code> (fils d'exécution).</li>
<li>Assurer que les données restent en vie tant qu'au moins un pointeur y accède, dans un environnement multithread.</li>
</ul>
</li>
<li>
<p><strong>RefCell<T></strong> : Fournit une mutabilité intérieure, permettant de modifier les données même lorsque l'instance RefCell est immuable. RefCell suit les emprunts à l'exécution, paniquant si les règles d'emprunt sont violées. <code>RefCell</code> est souvent utilisé pour :</p>
<ul>
<li>Contourner les règles d'emprunt statiques de Rust lorsque vous savez que le code respectera les règles d'emprunt à l'exécution.</li>
<li>Modifier des données partagées entre différentes parties d'un programme sans recourir à la mutabilité globale.</li>
<li>Assurer qu'un seul thread à la fois peut modifier les données partagées.</li>
<li>Optimiser les cas où des données pourraient être modifiées, mais sont souvent lues sans modification.</li>
<li>Réduire les coûts de clonage en ne clonant que lorsque c'est absolument nécessaire.</li>
</ul>
</li>
<li>
<p><strong>Cow<T></strong> : Clone On Write (COW) est un type d'énumération qui peut encapsuler soit une référence immuable vers des données (&amp;T), soit une version possédée (T) des données. Cow permet une flexibilité entre performance et propriété des données, clonant les données uniquement si une modification est nécessaire. Cow est utilisé pour :</p>
<ul>
<li>Optimiser les cas où des données pourraient être modifiées, mais sont souvent lues sans modification.</li>
<li>Réduire les coûts de clonage en ne clonant que lorsque c'est absolument nécessaire.</li>
</ul>
</li>
</ul>
<p>Ces pointeurs intelligents jouent un rôle essentiel dans la gestion de la mémoire et la manipulation des données en Rust, offrant à la fois flexibilité et sécurité.</p>
<h3 id="fonctions">Fonctions</h3>
<p>Les fonctions sont des blocs de code qui effectuent une tâche spécifique. En Rust, les fonctions sont déclarées en utilisant le mot-clé <code>fn</code>, suivi du nom de la fonction, de ses paramètres et de son type de retour. Voici un exemple de déclaration de fonction en Rust :</p>
<p>Syntaxe de base d'une fonction en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">nom_de_la_fonction</span></span>(paramètre1: Type, paramètre2: Type) -&gt; Type_de_retour {
        <span class="hljs-comment">// Corps de la fonction</span>
    }
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(x: <span class="hljs-built_in">i32</span>, y: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> {
        x + y
    }
    <span class="hljs-keyword">let</span> result = add(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le résultat est : {}"</span>, result); <span class="hljs-comment">// Le résultat est : 15</span>
}
</div></code></pre>
<p>Dans cet exemple, <code>fn add(x: i32, y: i32) -&gt; i32 { x + y }</code> déclare une fonction <code>add</code> qui prend deux paramètres <code>x</code> et <code>y</code> de type <code>i32</code> et renvoie un résultat de type <code>i32</code>. Le corps de la fonction <code>add</code> est <code>x + y</code>, qui ajoute les deux paramètres <code>x</code> et <code>y</code> et renvoie le résultat.</p>
<p>Pour appeler une fonction en Rust, vous pouvez utiliser le nom de la fonction suivi de ses paramètres entre parenthèses. Par exemple, <code>add(5, 10)</code> appelle la fonction <code>add</code> avec les paramètres <code>5</code> et <code>10</code> et stocke le résultat dans la variable <code>result</code>.</p>
<h3 id="commentaires">Commentaires</h3>
<p>Les commentaires sont des annotations dans le code source qui ne sont pas exécutées par le programme, mais qui fournissent des informations supplémentaires sur le code. En Rust, les commentaires peuvent être de deux types : les commentaires de ligne (<code>//</code>) et les commentaires de bloc (<code>/* ... */</code>). Voici un exemple de commentaires en Rust :</p>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-comment">// Ceci est un commentaire de ligne</span>
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>; <span class="hljs-comment">// Ceci est un commentaire de fin de ligne</span>
    <span class="hljs-comment">/*
    Ceci est un commentaire de bloc
    qui peut s'étendre sur plusieurs lignes
    */</span>
}
</div></code></pre>
<p>Dans cet exemple, <code>// Ceci est un commentaire de ligne</code> est un commentaire de ligne, <code>let x = 5; // Ceci est un commentaire de fin de ligne</code> est un commentaire de fin de ligne et <code>/* ... */</code> est un commentaire de bloc.</p>
<h3 id="exemples-de-programmes-rust-simples">Exemples de programmes Rust simples</h3>
<p>Voici quelques exemples de programmes Rust simples pour illustrer les concepts de base de Rust :</p>
<ul>
<li>Programme Rust simple pour afficher &quot;Hello, world!&quot; à l'écran :</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Hello, world!"</span>);
}
</div></code></pre>
<ul>
<li>Programme Rust simple pour ajouter deux nombres et afficher le résultat :</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(x: <span class="hljs-built_in">i32</span>, y: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> {
        x + y
    }
    <span class="hljs-keyword">let</span> result = add(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le résultat est : {}"</span>, result); <span class="hljs-comment">// Le résultat est : 15</span>
}
</div></code></pre>
<ul>
<li>Programme Rust simple pour déclarer une variable et afficher sa valeur :</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// La valeur de x est : 5</span>
}
</div></code></pre>
<ul>
<li>Programme Rust simple pour déclarer un tableau et afficher ses valeurs :</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: [<span class="hljs-built_in">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Un tableau de 5 entiers de 32 bits</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La première valeur de x est : {}"</span>, x[<span class="hljs-number">0</span>]); <span class="hljs-comment">// La première valeur de x est : 1</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La deuxième valeur de x est : {}"</span>, x[<span class="hljs-number">1</span>]); <span class="hljs-comment">// La deuxième valeur de x est : 2</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La troisième valeur de x est : {}"</span>, x[<span class="hljs-number">2</span>]); <span class="hljs-comment">// La troisième valeur de x est : 3</span>
}
</div></code></pre>
<ul>
<li>Programme Rust simple pour déclarer une chaîne de caractères et afficher sa valeur :</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: &amp;<span class="hljs-built_in">str</span> = <span class="hljs-string">"Hello, world!"</span>; <span class="hljs-comment">// Une chaîne de caractères littérale</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// La valeur de x est : Hello, world!</span>
}
</div></code></pre>
<ul>
<li>Programme Rust simple pour déclarer une référence et afficher sa valeur :</li>
</ul>
<pre class="hljs"><code><div>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">i32</span> = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">let</span> y: &amp;<span class="hljs-built_in">i32</span> = &amp;x; <span class="hljs-comment">// Une référence à x</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// La valeur de x est : 5</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de y est : {}"</span>, y); <span class="hljs-comment">// La valeur de y est : 5</span>
}
</div></code></pre>
<h1 id="contr%C3%B4le-de-flux">Contrôle de flux</h1>
<p>Le contrôle de flux est une technique utilisée pour gérer l'exécution des instructions dans un programme. En Rust, le contrôle de flux est réalisé à l'aide de structures de contrôle telles que <code>if</code>, <code>else</code>, <code>loop</code>, <code>while</code>, <code>for</code>, <code>match</code>, <code>break</code>, <code>continue</code>, <code>return</code>, etc. Ces structures de contrôle permettent de prendre des décisions, de répéter des instructions, de gérer les erreurs et de contrôler le flux d'exécution du programme.</p>
<h2 id="structures-de-contr%C3%B4le">Structures de contrôle</h2>
<p>Les structures de contrôle sont des instructions qui permettent de contrôler le flux d'exécution d'un programme. En Rust, les structures de contrôle les plus couramment utilisées sont <code>if</code>, <code>else</code>, <code>loop</code>, <code>while</code>, <code>for</code>, <code>match</code>, <code>break</code>, <code>continue</code>, <code>return</code>, etc. Ces structures de contrôle permettent de prendre des décisions, de répéter des instructions, de gérer les erreurs et de contrôler le flux d'exécution du programme.</p>
<h3 id="if-else-et-else-if"><code>if</code>, <code>else</code> et <code>else if</code></h3>
<ul>
<li><code>if</code> : L'instruction <code>if</code> est utilisée pour exécuter un bloc de code si une condition est vraie.</li>
</ul>
<p>Syntaxe de base de l'instruction <code>if</code> en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">if</span> condition {
        <span class="hljs-comment">// Bloc de code à exécuter si la condition est vraie</span>
    }
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x est positif"</span>);
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>if x &gt; 0 { println!(&quot;x est positif&quot;); }</code> exécute le bloc de code <code>println!(&quot;x est positif&quot;);</code> si la condition <code>x &gt; 0</code> est vraie.</p>
<ul>
<li><code>else</code> : L'instruction <code>else</code> est utilisée pour exécuter un bloc de code si la condition de l'instruction <code>if</code> est fausse.</li>
</ul>
<p>Syntaxe de base de l'instruction <code>else</code> en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">if</span> condition {
        <span class="hljs-comment">// Bloc de code à exécuter si la condition est vraie</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Bloc de code à exécuter si la condition est fausse</span>
    }
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x est positif"</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x est négatif ou nul"</span>);
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>if x &gt; 0 { println!(&quot;x est positif&quot;); } else { println!(&quot;x est négatif ou nul&quot;); }</code> exécute le bloc de code <code>println!(&quot;x est positif&quot;);</code> si la condition <code>x &gt; 0</code> est vraie, sinon il exécute le bloc de code <code>println!(&quot;x est négatif ou nul&quot;);</code>.</p>
<ul>
<li><code>else if</code> : L'instruction <code>else if</code> est utilisée pour exécuter un bloc de code si une autre condition est vraie.</li>
</ul>
<p>Syntaxe de base de l'instruction <code>else if</code> en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">if</span> condition1 {
        <span class="hljs-comment">// Bloc de code à exécuter si la condition1 est vraie</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> condition2 {
        <span class="hljs-comment">// Bloc de code à exécuter si la condition2 est vraie</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// Bloc de code à exécuter si aucune des conditions n'est vraie</span>
    }
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x est positif"</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x est négatif"</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x est nul"</span>);
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>if x &gt; 0 { println!(&quot;x est positif&quot;); } else if x &lt; 0 { println!(&quot;x est négatif&quot;); } else { println!(&quot;x est nul&quot;); }</code> exécute le bloc de code <code>println!(&quot;x est positif&quot;);</code> si la condition <code>x &gt; 0</code> est vraie, sinon il exécute le bloc de code <code>println!(&quot;x est négatif&quot;);</code> si la condition <code>x &lt; 0</code> est vraie, sinon il exécute le bloc de code <code>println!(&quot;x est nul&quot;);</code>.</p>
<h3 id="loop"><code>loop</code></h3>
<p>L'instruction <code>loop</code> est utilisée pour exécuter un bloc de code en boucle indéfiniment jusqu'à ce qu'une condition de sortie soit rencontrée.</p>
<p>Syntaxe de base de l'instruction <code>loop</code> en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-comment">// Bloc de code à exécuter en boucle</span>
    }
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x = {}"</span>, x);
        x += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> x == <span class="hljs-number">5</span> {
            <span class="hljs-keyword">break</span>;
        }
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>loop { println!(&quot;x = {}&quot;, x); x += 1; if x == 5 { break; } }</code> exécute le bloc de code <code>println!(&quot;x = {}&quot;, x); x += 1;</code> en boucle jusqu'à ce que la condition <code>x == 5</code> soit vraie, puis il sort de la boucle à l'aide de l'instruction <code>break</code>.</p>
<ul>
<li>let mut x = 0; : déclare une variable <code>x</code> et l'initialise avec la valeur <code>0</code>.</li>
<li>loop { ... } : exécute le bloc de code en boucle indéfiniment.</li>
<li>println!(&quot;x = {}&quot;, x); : affiche la valeur de <code>x</code>.</li>
<li>x += 1; : incrémente la valeur de <code>x</code> de <code>1</code>.</li>
<li>if x == 5 { break; } : vérifie si la valeur de <code>x</code> est égale à <code>5</code>, puis sort de la boucle à l'aide de l'instruction <code>break</code>.</li>
<li>break; : sort de la boucle.</li>
</ul>
<h3 id="while"><code>while</code></h3>
<p>L'instruction <code>while</code> est utilisée pour exécuter un bloc de code en boucle tant qu'une condition est vraie.</p>
<p>Syntaxe de base de l'instruction <code>while</code> en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">while</span> condition {
        <span class="hljs-comment">// Bloc de code à exécuter en boucle tant que la condition est vraie</span>
    }
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> x &lt; <span class="hljs-number">5</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x = {}"</span>, x);
        x += <span class="hljs-number">1</span>;
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>while x &lt; 5 { println!(&quot;x = {}&quot;, x); x += 1; }</code> exécute le bloc de code <code>println!(&quot;x = {}&quot;, x); x += 1;</code> en boucle tant que la condition <code>x &lt; 5</code> est vraie.</p>
<ul>
<li>let mut x = 0; : déclare une variable <code>x</code> et l'initialise avec la valeur <code>0</code>.</li>
<li>while x &lt; 5 { ... } : exécute le bloc de code en boucle tant que la condition <code>x &lt; 5</code> est vraie.</li>
<li>println!(&quot;x = {}&quot;, x); : affiche la valeur de <code>x</code>.</li>
<li>x += 1; : incrémente la valeur de <code>x</code> de <code>1</code>.</li>
</ul>
<h3 id="for"><code>for</code></h3>
<p>L'instruction <code>for</code> est utilisée pour exécuter un bloc de code pour chaque élément d'une collection (par exemple, un tableau, une plage, etc.).</p>
<p>Syntaxe de base de l'instruction <code>for</code> en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> collection {
        <span class="hljs-comment">// Bloc de code à exécuter pour chaque élément de la collection</span>
    }
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
    <span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> numbers.iter() {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"number = {}"</span>, number);
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>for number in numbers.iter() { println!(&quot;number = {}&quot;, number); }</code> exécute le bloc de code <code>println!(&quot;number = {}&quot;, number);</code> pour chaque élément de la collection <code>numbers</code>.</p>
<ul>
<li>let numbers = [1, 2, 3, 4, 5]; : déclare un tableau <code>numbers</code> avec les valeurs <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code> et <code>5</code>.</li>
<li>for number in numbers.iter() { ... } : exécute le bloc de code pour chaque élément de la collection <code>numbers</code>.</li>
<li>println!(&quot;number = {}&quot;, number); : affiche la valeur de <code>number</code>.</li>
<li>numbers.iter() : itère sur les éléments de la collection <code>numbers</code>.</li>
<li>number : représente chaque élément de la collection <code>numbers</code>.</li>
</ul>
<h3 id="match"><code>match</code></h3>
<p>L'instruction <code>match</code> est utilisée pour effectuer des correspondances de motifs sur une valeur et exécuter un bloc de code en fonction du motif correspondant.</p>
<p>Syntaxe de base de l'instruction <code>match</code> en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">match</span> value {
        pattern1 =&gt; {
            <span class="hljs-comment">// Bloc de code à exécuter si value correspond à pattern1</span>
        }
        pattern2 =&gt; {
            <span class="hljs-comment">// Bloc de code à exécuter si value correspond à pattern2</span>
        }
        _ =&gt; {
            <span class="hljs-comment">// Bloc de code à exécuter si aucune des conditions n'est vraie</span>
        }
    }
}
</div></code></pre>
<p>Exemple 1 de code Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">match</span> x {
        <span class="hljs-number">1</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x est égal à 1"</span>),
        <span class="hljs-number">2</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x est égal à 2"</span>),
        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x n'est ni égal à 1 ni à 2"</span>),
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>match x { 1 =&gt; println!(&quot;x est égal à 1&quot;), 2 =&gt; println!(&quot;x est égal à 2&quot;), _ =&gt; println!(&quot;x n'est ni égal à 1 ni à 2&quot;), }</code> effectue des correspondances de motifs sur la valeur <code>x</code> et exécute le bloc de code correspondant en fonction du motif correspondant.</p>
<ul>
<li>let x = 5; : déclare une variable <code>x</code> et l'initialise avec la valeur <code>5</code>.</li>
<li>match x { ... } : effectue des correspondances de motifs sur la valeur <code>x</code>.</li>
<li>1 =&gt; println!(&quot;x est égal à 1&quot;) : exécute le bloc de code si <code>x</code> est égal à <code>1</code>.</li>
<li>2 =&gt; println!(&quot;x est égal à 2&quot;) : exécute le bloc de code si <code>x</code> est égal à <code>2</code>.</li>
<li>_ =&gt; println!(&quot;x n'est ni égal à 1 ni à 2&quot;) : exécute le bloc de code par défaut si aucune des conditions n'est vraie.</li>
</ul>
<p>Exemple 2 de code Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">match</span> x {
        <span class="hljs-number">1</span> | <span class="hljs-number">2</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x est égal à 1 ou 2"</span>), <span class="hljs-comment">// Correspondance multiple</span>
        <span class="hljs-number">3</span>..=<span class="hljs-number">5</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x est compris entre 3 et 5"</span>), <span class="hljs-comment">// Correspondance de plage</span>
        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x n'est ni égal à 1 ni à 2, ni compris entre 3 et 5"</span>), <span class="hljs-comment">// Correspondance par défaut</span>
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>match x { 1 | 2 =&gt; println!(&quot;x est égal à 1 ou 2&quot;), 3..=5 =&gt; println!(&quot;x est compris entre 3 et 5&quot;), _ =&gt; println!(&quot;x n'est ni égal à 1 ni à 2, ni compris entre 3 et 5&quot;), }</code> effectue des correspondances de motifs plus complexes sur la valeur <code>x</code> et exécute le bloc de code correspondant en fonction du motif correspondant.</p>
<ul>
<li>let x = 5; : déclare une variable <code>x</code> et l'initialise avec la valeur <code>5</code>.</li>
<li>match x { ... } : effectue des correspondances de motifs sur la valeur <code>x</code>.</li>
<li>1 | 2 =&gt; println!(&quot;x est égal à 1 ou 2&quot;) : exécute le bloc de code si <code>x</code> est égal à <code>1</code> ou <code>2</code>.</li>
<li>3..=5 =&gt; println!(&quot;x est compris entre 3 et 5&quot;) : exécute le bloc de code si <code>x</code> est compris entre <code>3</code> et <code>5</code>.</li>
<li>_ =&gt; println!(&quot;x n'est ni égal à 1 ni à 2, ni compris entre 3 et 5&quot;) : exécute le bloc de code par défaut si aucune des conditions n'est vraie.</li>
</ul>
<h3 id="break"><code>break</code></h3>
<p>L'instruction <code>break</code> est utilisée pour sortir d'une boucle.</p>
<p>Syntaxe de base de l'instruction <code>break</code> en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">if</span> condition {
            <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-comment">// ...</span>
    }
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x = {}"</span>, x);
        x += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> x == <span class="hljs-number">5</span> {
            <span class="hljs-keyword">break</span>;
        }
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>loop { println!(&quot;x = {}&quot;, x); x += 1; if x == 5 { break; } }</code> exécute le bloc de code <code>println!(&quot;x = {}&quot;, x); x += 1;</code> en boucle jusqu'à ce que la condition <code>x == 5</code> soit vraie, puis il sort de la boucle à l'aide de l'instruction <code>break</code>.</p>
<ul>
<li>let mut x = 0; : déclare une variable <code>x</code> et l'initialise avec la valeur <code>0</code>.</li>
<li>loop { ... } : exécute le bloc de code en boucle indéfiniment.</li>
<li>println!(&quot;x = {}&quot;, x); : affiche la valeur de <code>x</code>.</li>
<li>x += 1; : incrémente la valeur de <code>x</code> de <code>1</code>.</li>
<li>if x == 5 { break; } : vérifie si la valeur de <code>x</code> est égale à <code>5</code>, puis sort de la boucle à l'aide de l'instruction <code>break</code>.</li>
<li>break; : sort de la boucle.</li>
</ul>
<h3 id="continue"><code>continue</code></h3>
<p>L'instruction <code>continue</code> est utilisée pour passer à l'itération suivante d'une boucle.</p>
<p>Syntaxe de base de l'instruction <code>continue</code> en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">if</span> condition {
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-comment">// ...</span>
    }
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">5</span> {
        <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> {
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x = {}"</span>, x); <span class="hljs-comment">// Affichera les valeurs impaires de x : 1, 2, 3, 4</span>
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>for x in 0..5 { if x % 2 == 0 { continue; } println!(&quot;x = {}&quot;, x); }</code> exécute le bloc de code <code>println!(&quot;x = {}&quot;, x);</code> pour chaque élément de la plage <code>0..5</code>, mais il passe à l'itération suivante si la condition <code>x % 2 == 0</code> est vraie.</p>
<ul>
<li>for x in 0..5 { ... } : exécute le bloc de code pour chaque élément de la plage <code>0..5</code>.</li>
<li>if x % 2 == 0 { continue; } : passe à l'itération suivante si la condition <code>x % 2 == 0</code> est vraie.</li>
<li>println!(&quot;x = {}&quot;, x); : affiche la valeur de <code>x</code>.</li>
<li>x % 2 : calcule le reste de la division de <code>x</code> par <code>2</code>.</li>
<li>continue; : passe à l'itération suivante.</li>
<li>0..5 : représente une plage de <code>0</code> à <code>5</code> (excluant <code>5</code>).</li>
<li>x : représente chaque élément de la plage <code>0..5</code>.</li>
<li>0, 1, 2, 3, 4 : sont les éléments de la plage <code>0..5</code>.</li>
</ul>
<h3 id="return"><code>return</code></h3>
<p>L'instruction <code>return</code> est utilisée pour renvoyer une valeur à partir d'une fonction.</p>
<p>Syntaxe de base de l'instruction <code>return</code> en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">nom_de_la_fonction</span></span>(paramètre1: Type, paramètre2: Type) -&gt; Type_de_retour {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">if</span> condition {
        <span class="hljs-keyword">return</span> valeur;
    }
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add</span></span>(x: <span class="hljs-built_in">i32</span>, y: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> {
    <span class="hljs-keyword">return</span> x + y;
}
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> result = add(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le résultat est : {}"</span>, result); <span class="hljs-comment">// Le résultat est : 15</span>
}
</div></code></pre>
<p>Dans cet exemple, <code>return x + y;</code> renvoie la valeur de <code>x + y</code> à partir de la fonction <code>add</code>.</p>
<ul>
<li>fn add(x: i32, y: i32) -&gt; i32 { ... } : déclare une fonction <code>add</code> qui prend deux paramètres <code>x</code> et <code>y</code> de type <code>i32</code> et renvoie un résultat de type <code>i32</code>.</li>
<li>return x + y; : renvoie la valeur de <code>x + y</code> à partir de la fonction <code>add</code>.</li>
<li>let result = add(5, 10); : appelle la fonction <code>add</code> avec les paramètres <code>5</code> et <code>10</code> et stocke le résultat dans la variable <code>result</code>.</li>
<li>println!(&quot;Le résultat est : {}&quot;, result); : affiche le résultat.</li>
<li>5, 10 : sont les paramètres de la fonction <code>add</code>.</li>
<li>15 : est le résultat de l'addition de <code>5</code> et <code>10</code>.</li>
<li>result : est la variable qui stocke le résultat.</li>
<li>Le résultat est : 15 : est le résultat affiché.</li>
</ul>
<h1 id="concepts-avanc%C3%A9s">Concepts avancés</h1>
<p>Les concepts avancés en Rust comprennent les types de données avancés, les traits, les génériques, les macros, la gestion des erreurs, etc. Ces concepts permettent de créer des programmes plus complexes et plus flexibles en Rust.</p>
<h2 id="pattern-matching-et-contr%C3%B4le-de-flux">Pattern Matching et Contrôle de Flux</h2>
<p>Le pattern matching est une technique utilisée pour effectuer des correspondances de motifs sur une valeur et exécuter un bloc de code en fonction du motif correspondant. En Rust, le pattern matching est réalisé à l'aide de l'instruction <code>match</code>, qui permet de comparer une valeur à une série de motifs et d'exécuter un bloc de code en fonction du motif correspondant.</p>
<h3 id="match"><code>match</code></h3>
<p>L'instruction <code>match</code> est utilisée pour effectuer des correspondances de motifs sur une valeur et exécuter un bloc de code en fonction du motif correspondant.</p>
<p>Syntaxe de base de l'instruction <code>match</code> en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">match</span> value {
        pattern1 =&gt; {
            <span class="hljs-comment">// Bloc de code à exécuter si value correspond à pattern1</span>
        }
        pattern2 =&gt; {
            <span class="hljs-comment">// Bloc de code à exécuter si value correspond à pattern2</span>
        }
        _ =&gt; {
            <span class="hljs-comment">// Bloc de code à exécuter si aucune des conditions n'est vraie</span>
        }
    }
}
</div></code></pre>
<p>Exemple 1 de code Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">match</span> x {
        <span class="hljs-number">1</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x est égal à 1"</span>),
        <span class="hljs-number">2</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x est égal à 2"</span>),
        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x n'est ni égal à 1 ni à 2"</span>),
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>match x { 1 =&gt; println!(&quot;x est égal à 1&quot;), 2 =&gt; println!(&quot;x est égal à 2&quot;), _ =&gt; println!(&quot;x n'est ni égal à 1 ni à 2&quot;), }</code> effectue des correspondances de motifs sur la valeur <code>x</code> et exécute le bloc de code correspondant en fonction du motif correspondant.</p>
<ul>
<li>let x = 5; : déclare une variable <code>x</code> et l'initialise avec la valeur <code>5</code>.</li>
<li>match x { ... } : effectue des correspondances de motifs sur la valeur <code>x</code>.</li>
<li>1 =&gt; println!(&quot;x est égal à 1&quot;) : exécute le bloc de code si <code>x</code> est égal à <code>1</code>.</li>
<li>2 =&gt; println!(&quot;x est égal à 2&quot;) : exécute le bloc de code si <code>x</code> est égal à <code>2</code>.</li>
<li>_ =&gt; println!(&quot;x n'est ni égal à 1 ni à 2&quot;) : exécute le bloc de code par défaut si aucune des conditions n'est vraie.</li>
</ul>
<p>Exemple 2 de code Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">match</span> x {
        <span class="hljs-number">1</span> | <span class="hljs-number">2</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x est égal à 1 ou 2"</span>), <span class="hljs-comment">// Correspondance multiple</span>
        <span class="hljs-number">3</span>..=<span class="hljs-number">5</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x est compris entre 3 et 5"</span>), <span class="hljs-comment">// Correspondance de plage</span>
        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x n'est ni égal à 1 ni à 2, ni compris entre 3 et 5"</span>), <span class="hljs-comment">// Correspondance par défaut</span>
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>match x { 1 | 2 =&gt; println!(&quot;x est égal à 1 ou 2&quot;), 3..=5 =&gt; println!(&quot;x est compris entre 3 et 5&quot;), _ =&gt; println!(&quot;x n'est ni égal à 1 ni à 2, ni compris entre 3 et 5&quot;), }</code> effectue des correspondances de motifs plus complexes sur la valeur <code>x</code> et exécute le bloc de code correspondant en fonction du motif correspondant.</p>
<ul>
<li>let x = 5; : déclare une variable <code>x</code> et l'initialise avec la valeur <code>5</code>.</li>
<li>match x { ... } : effectue des correspondances de motifs sur la valeur <code>x</code>.</li>
<li>1 | 2 =&gt; println!(&quot;x est égal à 1 ou 2&quot;) : exécute le bloc de code si <code>x</code> est égal à <code>1</code> ou <code>2</code>.</li>
<li>3..=5 =&gt; println!(&quot;x est compris entre 3 et 5&quot;) : exécute le bloc de code si <code>x</code> est compris entre <code>3</code> et <code>5</code>.</li>
<li>_ =&gt; println!(&quot;x n'est ni égal à 1 ni à 2, ni compris entre 3 et 5&quot;) : exécute le bloc de code par défaut si aucune des conditions n'est vraie.</li>
</ul>
<h3 id="comparaison-avec-if-let-et-while-let">Comparaison avec <code>if let</code> et <code>while let</code></h3>
<h4 id="if-let"><code>if let</code></h4>
<p>L'instruction <code>if let</code> est utilisée pour effectuer des correspondances de motifs sur une valeur et exécuter un bloc de code en fonction du motif correspondant.</p>
<p>Syntaxe de base de l'instruction <code>if let</code> en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> pattern = value {
        <span class="hljs-comment">// Bloc de code à exécuter si value correspond à pattern</span>
    }
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = <span class="hljs-literal">Some</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// Une option contenant la valeur 5</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(value) = x { <span class="hljs-comment">// Correspondance de motif sur l'option</span>
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur est : {}"</span>, value); <span class="hljs-comment">// La valeur est : 5</span>
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>if let Some(value) = x { println!(&quot;La valeur est : {}&quot;, value); }</code> effectue des correspondances de motifs sur l'option <code>x</code> et exécute le bloc de code <code>println!(&quot;La valeur est : {}&quot;, value);</code> si l'option contient une valeur.</p>
<ul>
<li>let x = Some(5); : déclare une option <code>x</code> contenant la valeur <code>5</code>.</li>
<li>if let Some(value) = x { ... } : effectue des correspondances de motifs sur l'option <code>x</code>.</li>
<li>println!(&quot;La valeur est : {}&quot;, value); : affiche la valeur de <code>value</code>.</li>
<li>Some(5) : représente une option contenant la valeur <code>5</code>.</li>
</ul>
<h4 id="while-let"><code>while let</code></h4>
<p>L'instruction <code>while let</code> est utilisée pour effectuer des correspondances de motifs sur une valeur et exécuter un bloc de code en boucle tant que le motif correspondant est vrai.</p>
<p>Syntaxe de base de l'instruction <code>while let</code> en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> pattern = value {
        <span class="hljs-comment">// Bloc de code à exécuter en boucle tant que value correspond à pattern</span>
    }
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = <span class="hljs-literal">Some</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// Une option contenant la valeur 5</span>
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(value) = x { <span class="hljs-comment">// Correspondance de motif sur l'option</span>
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur est : {}"</span>, value); <span class="hljs-comment">// La valeur est : 5</span>
        x = <span class="hljs-literal">None</span>; <span class="hljs-comment">// Affecte à x la valeur None pour sortir de la boucle</span>
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>while let Some(value) = x { println!(&quot;La valeur est : {}&quot;, value); x = None; }</code> effectue des correspondances de motifs sur l'option <code>x</code> et exécute le bloc de code <code>println!(&quot;La valeur est : {}&quot;, value); x = None;</code> en boucle tant que l'option contient une valeur.</p>
<ul>
<li>let mut x = Some(5); : déclare une option <code>x</code> contenant la valeur <code>5</code>.</li>
<li>while let Some(value) = x { ... } : effectue des correspondances de motifs sur l'option <code>x</code> en boucle tant que l'option contient une valeur.</li>
<li>println!(&quot;La valeur est : {}&quot;, value); : affiche la valeur de <code>value</code>.</li>
<li>x = None; : affecte à <code>x</code> la valeur <code>None</code> pour sortir de la boucle.</li>
<li>Some(5) : représente une option contenant la valeur <code>5</code>.</li>
</ul>
<h4 id="if-let-et-while-let-avec-des-%C3%A9num%C3%A9rations"><code>if let</code> et <code>while let</code> avec des énumérations</h4>
<p>L'instruction <code>if let</code> et <code>while let</code> peut être utilisée avec des énumérations pour effectuer des correspondances de motifs sur les variantes de l'énumération et exécuter un bloc de code en fonction de la variante correspondante.</p>
<p>Exemple 1 de code Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Couleur</span></span> {
        Rouge,
        Vert,
        Bleu,
    }
    <span class="hljs-keyword">let</span> couleur = Couleur::Rouge;
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> Couleur::Rouge = couleur {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La couleur est rouge"</span>);
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>if let Couleur::Rouge = couleur { println!(&quot;La couleur est rouge&quot;); }</code> effectue des correspondances de motifs sur la variante <code>Rouge</code> de l'énumération <code>Couleur</code> et exécute le bloc de code <code>println!(&quot;La couleur est rouge&quot;);</code> si la variante correspondante est trouvée.</p>
<p>Exemple 2 de code Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">OptionEntier</span></span> {
        Valeur(<span class="hljs-built_in">i32</span>),
        Aucune,
    }
    <span class="hljs-keyword">let</span> x = OptionEntier::Valeur(<span class="hljs-number">5</span>);
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> OptionEntier::Valeur(valeur) = x {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur est : {}"</span>, valeur);
        x = OptionEntier::Aucune;
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>while let OptionEntier::Valeur(valeur) = x { println!(&quot;La valeur est : {}&quot;, valeur); x = OptionEntier::Aucune; }</code> effectue des correspondances de motifs sur la variante <code>Valeur</code> de l'énumération <code>OptionEntier</code> et exécute le bloc de code <code>println!(&quot;La valeur est : {}&quot;, valeur); x = OptionEntier::Aucune;</code> en boucle tant que la variante correspondante est trouvée.</p>
<h3 id="patterns-exhaustifs-et-le-joker">Patterns exhaustifs et le joker <code>_</code></h3>
<p>En Rust, les correspondances de motifs doivent être exhaustives, ce qui signifie que toutes les variantes d'une énumération doivent être prises en compte. Pour gérer les variantes non prises en compte, le joker <code>_</code> peut être utilisé pour capturer toutes les autres variantes.</p>
<h4 id="patterns-exhaustifs">Patterns exhaustifs</h4>
<p>Les patterns exhaustifs sont des correspondances de motifs qui prennent en compte toutes les variantes d'une énumération.</p>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Couleur</span></span> {
        Rouge,
        Vert,
        Bleu,
    }
    <span class="hljs-keyword">let</span> couleur = Couleur::Rouge;
    <span class="hljs-keyword">match</span> couleur {
        Couleur::Rouge =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La couleur est rouge"</span>),
        Couleur::Vert =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La couleur est verte"</span>),
        Couleur::Bleu =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La couleur est bleue"</span>),
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>match couleur { Couleur::Rouge =&gt; println!(&quot;La couleur est rouge&quot;), Couleur::Vert =&gt; println!(&quot;La couleur est verte&quot;), Couleur::Bleu =&gt; println!(&quot;La couleur est bleue&quot;), }</code> effectue des correspondances de motifs exhaustives sur la valeur <code>couleur</code> et exécute le bloc de code correspondant en fonction de la variante correspondante.</p>
<h4 id="le-joker">Le joker <code>_</code></h4>
<p>Le joker <code>_</code> est utilisé pour capturer toutes les autres variantes non prises en compte dans les correspondances de motifs.</p>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Couleur</span></span> {
        Rouge,
        Vert,
        Bleu,
    }
    <span class="hljs-keyword">let</span> couleur = Couleur::Rouge;
    <span class="hljs-keyword">match</span> couleur {
        Couleur::Rouge =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La couleur est rouge"</span>),
        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La couleur est inconnue"</span>), <span class="hljs-comment">// Capturer toutes les autres variantes</span>
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>match couleur { Couleur::Rouge =&gt; println!(&quot;La couleur est rouge&quot;), _ =&gt; println!(&quot;La couleur est inconnue&quot;), }</code> effectue des correspondances de motifs sur la valeur <code>couleur</code> et exécute le bloc de code <code>println!(&quot;La couleur est inconnue&quot;);</code> pour toutes les autres variantes non prises en compte.</p>
<h3 id="matching-sur-les-%C3%A9num%C3%A9rations-imbriqu%C3%A9es">Matching sur les énumérations imbriquées</h3>
<p>Les énumérations imbriquées sont des énumérations qui contiennent d'autres énumérations comme variantes. En Rust, les correspondances de motifs peuvent être utilisées pour effectuer des correspondances sur les variantes des énumérations imbriquées.</p>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Couleur</span></span> {
        Rouge,
        Vert,
        Bleu,
    }
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Forme</span></span> {
        Cercle(Couleur),
        Rectangle(Couleur),
    }
    <span class="hljs-keyword">let</span> forme = Forme::Cercle(Couleur::Rouge);
    <span class="hljs-keyword">match</span> forme {
        Forme::Cercle(Couleur::Rouge) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La forme est un cercle rouge"</span>),
        Forme::Cercle(Couleur::Vert) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La forme est un cercle vert"</span>),
        Forme::Rectangle(Couleur::Rouge) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La forme est un rectangle rouge"</span>),
        Forme::Rectangle(Couleur::Vert) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La forme est un rectangle vert"</span>),
        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La forme est inconnue"</span>),
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>match forme { Forme::Cercle(Couleur::Rouge) =&gt; println!(&quot;La forme est un cercle rouge&quot;), Forme::Cercle(Couleur::Vert) =&gt; println!(&quot;La forme est un cercle vert&quot;), Forme::Rectangle(Couleur::Rouge) =&gt; println!(&quot;La forme est un rectangle rouge&quot;), Forme::Rectangle(Couleur::Vert) =&gt; println!(&quot;La forme est un rectangle vert&quot;), _ =&gt; println!(&quot;La forme est inconnue&quot;), }</code> effectue des correspondances de motifs sur la valeur <code>forme</code> et exécute le bloc de code correspondant en fonction de la variante correspondante.</p>
<h3 id="matching-sur-les-valeurs-de-r%C3%A9f%C3%A9rence">Matching sur les valeurs de référence</h3>
<p>Les correspondances de motifs peuvent être utilisées pour effectuer des correspondances sur les valeurs de référence en Rust.</p>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = &amp;<span class="hljs-number">5</span>; <span class="hljs-comment">// &amp;5 est une référence à la valeur 5</span>
    <span class="hljs-keyword">match</span> x {
        &amp;val =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur est : {}"</span>, val), <span class="hljs-comment">// &amp;val correspond à la valeur de référence</span>
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>match x { &amp;val =&gt; println!(&quot;La valeur est : {}&quot;, val), }</code> effectue des correspondances de motifs sur la valeur de référence <code>x</code> et exécute le bloc de code <code>println!(&quot;La valeur est : {}&quot;, val);</code> pour la valeur de référence <code>5</code>.</p>
<h3 id="matching-sur-les-tuples">Matching sur les tuples</h3>
<p>Les correspondances de motifs peuvent être utilisées pour effectuer des correspondances sur les tuples en Rust.</p>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> point = (<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);
    <span class="hljs-keyword">match</span> point {
        (x, y) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x = {}, y = {}"</span>, x, y), <span class="hljs-comment">// (x, y) correspond aux éléments du tuple</span>
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>match point { (x, y) =&gt; println!(&quot;x = {}, y = {}&quot;, x, y), }</code> effectue des correspondances de motifs sur le tuple <code>point</code> et exécute le bloc de code <code>println!(&quot;x = {}, y = {}&quot;, x, y);</code> pour les éléments du tuple <code>5</code> et <code>10</code>.</p>
<h3 id="matching-sur-les-pointeurs-intelligents">Matching sur les pointeurs intelligents</h3>
<p>Les correspondances de motifs peuvent être utilisées pour effectuer des correspondances sur les pointeurs intelligents en Rust.</p>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = <span class="hljs-built_in">Box</span>::new(<span class="hljs-number">5</span>); <span class="hljs-comment">// Box::new(5) crée un pointeur intelligent contenant la valeur 5</span>
    <span class="hljs-keyword">match</span> x {
        val =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur est : {}"</span>, val), <span class="hljs-comment">// val correspond au pointeur intelligent</span>
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>match x { val =&gt; println!(&quot;La valeur est : {}&quot;, val), }</code> effectue des correspondances de motifs sur le pointeur intelligent <code>x</code> et exécute le bloc de code <code>println!(&quot;La valeur est : {}&quot;, val);</code> pour la valeur <code>5</code> du pointeur intelligent.</p>
<h3 id="matching-sur-les-cha%C3%AEnes-de-caract%C3%A8res">Matching sur les chaînes de caractères</h3>
<p>Les correspondances de motifs peuvent être utilisées pour effectuer des correspondances sur les chaînes de caractères en Rust.</p>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> texte = <span class="hljs-string">"Hello, World!"</span>;
    <span class="hljs-keyword">match</span> texte {
        <span class="hljs-string">"Hello, World!"</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le texte est : Hello, World!"</span>),
        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le texte est inconnu"</span>),
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>match texte { &quot;Hello, World!&quot; =&gt; println!(&quot;Le texte est : Hello, World!&quot;), _ =&gt; println!(&quot;Le texte est inconnu&quot;), }</code> effectue des correspondances de motifs sur la chaîne de caractères <code>texte</code> et exécute le bloc de code <code>println!(&quot;Le texte est : Hello, World!&quot;);</code> si la chaîne de caractères correspondante est trouvée.</p>
<h3 id="guards-dans-les-patterns">Guards dans les patterns</h3>
<p>Les guards dans les patterns sont des conditions supplémentaires qui peuvent être utilisées pour filtrer les correspondances de motifs en Rust.</p>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">match</span> x {
        val <span class="hljs-keyword">if</span> val &lt; <span class="hljs-number">0</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur est négative"</span>),
        val <span class="hljs-keyword">if</span> val &gt; <span class="hljs-number">0</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur est positive"</span>),
        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur est nulle"</span>),
    }
}
</div></code></pre>
<p>Détaillons ce code :</p>
<ul>
<li>let x = 5; : déclare une variable <code>x</code> et l'initialise avec la valeur <code>5</code>.</li>
<li>match x { ... } : effectue des correspondances de motifs sur la valeur <code>x</code>.</li>
<li>val if val &lt; 0 : est un garde qui filtre les correspondances de motifs si <code>val</code> est inférieur à <code>0</code>.</li>
<li>val if val &lt; 0 =&gt; println!(&quot;La valeur est négative&quot;) : exécute le bloc de code si <code>val</code> est inférieur à <code>0</code>.</li>
<li>val if val &gt; 0 =&gt; println!(&quot;La valeur est positive&quot;) : exécute le bloc de code si <code>val</code> est supérieur à <code>0</code>.</li>
<li>_ =&gt; println!(&quot;La valeur est nulle&quot;) : exécute le bloc de code par défaut si aucune des conditions n'est vraie.</li>
</ul>
<h2 id="g%C3%A9n%C3%A9riques">Génériques</h2>
<p>En Rust, les types génériques permettent de définir des fonctions, des structures, des énumérations ou des méthodes qui peuvent opérer sur plusieurs types de données différents, plutôt que sur un seul. L'utilisation de types génériques améliore la capacité de réutilisation du code, réduit la duplication et augmente la clarté en traitant explicitement les intentions de types.
Les génériques sont une fonctionnalité de programmation qui permet de définir des types de données et des fonctions qui peuvent être utilisés avec différents types de données sans duplication de code. En Rust, les génériques sont définis à l'aide du mot-clé <code>fn</code> suivi du nom de la fonction, des paramètres génériques entre crochets angulaires <code>&lt;...&gt;</code>, et des types de données génériques <code>T</code>, <code>U</code>, <code>V</code>, <code>W</code>.</p>
<p>Syntaxe de base des génériques en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">nom_de_la_fonction</span></span>&lt;T, U, V&gt;(paramètre1: T, paramètre2: U) -&gt; V {
    <span class="hljs-comment">// ...</span>
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">maximum</span></span>&lt;T: <span class="hljs-built_in">PartialOrd</span>&gt;(liste: &amp;[T]) -&gt; &amp;T { <span class="hljs-comment">// T est un type générique qui implémente PartialOrd. liste est une référence à un tableau de T. &amp;T est une référence à un T.</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> max = &amp;liste[<span class="hljs-number">0</span>]; <span class="hljs-comment">// max est une référence à la première valeur de liste.</span>
    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> liste {  <span class="hljs-comment">// Pour chaque élément de liste...</span>
        <span class="hljs-keyword">if</span> element &gt; max { <span class="hljs-comment">// Si l'élément est supérieur à max...</span>
            max = element; <span class="hljs-comment">// Affecter l'élément à max.</span>
        }
    }
    max <span class="hljs-comment">// Retourner max.</span>
}

<span class="hljs-comment">// Appel de la fonction maximum avec un tableau de nombres.</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> nombres = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>];
    <span class="hljs-keyword">let</span> max = maximum(&amp;nombres); <span class="hljs-comment">// Appel de la fonction maximum avec un tableau de nombres.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le maximum est : {}"</span>, max); <span class="hljs-comment">// Le maximum est : 10</span>
}
</div></code></pre>
<p>Voyons en détail ce code :</p>
<ul>
<li>fn maximum&lt;T: PartialOrd&gt;(liste: &amp;[T]) -&gt; &amp;T { ... } : déclare une fonction <code>maximum</code> avec un type générique <code>T</code> qui implémente <code>PartialOrd</code>, un paramètre <code>liste</code> qui est une référence à un tableau de <code>T</code>, et un type de retour <code>&amp;T</code> qui est une référence à un <code>T</code>.</li>
<li>let mut max = &amp;liste[0]; : déclare une variable <code>max</code> qui est une référence à la première valeur de <code>liste</code>.</li>
<li>for element in liste { ... } : itère sur chaque élément de <code>liste</code>.</li>
<li>if element &gt; max { ... } : vérifie si l'élément est supérieur à <code>max</code>.</li>
<li>max = element; : affecte l'élément à <code>max</code>.</li>
<li>max : est la valeur maximale de <code>liste</code>.</li>
<li>&amp;nombres : est une référence à un tableau de nombres.</li>
<li>Le maximum est : 10 : est le résultat affiché.</li>
</ul>
<h3 id="les-traits">Les traits</h3>
<p>Les traits sont une fonctionnalité de programmation qui permet de définir des comportements communs pour différents types de données en Rust. Les traits sont similaires aux interfaces dans d'autres langages de programmation et permettent de définir des méthodes et des comportements qui peuvent être implémentés par différents types de données. Les traits sont utilisés pour définir des comportements communs pour différents types de données en Rust. Ils permettent de définir des méthodes et des comportements qui peuvent être implémentés par différents types de données. Les traits sont similaires aux interfaces dans d'autres langages de programmation et sont utilisés pour définir des comportements communs pour différents types de données.</p>
<p>Syntaxe de base des traits en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">NomDuTrait</span></span> {
    <span class="hljs-comment">// Définition des méthodes et des comportements du trait</span>
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Affichable</span></span> {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">afficher</span></span>(&amp;<span class="hljs-keyword">self</span>); <span class="hljs-comment">// Définition d'une méthode afficher pour le trait Affichable.</span>
}

<span class="hljs-comment">// Définition d'une structure Point avec les champs x et y.</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> {
    x: <span class="hljs-built_in">i32</span>,
    y: <span class="hljs-built_in">i32</span>,
}

<span class="hljs-comment">// Implémentation du trait Affichable pour la structure Point.</span>
<span class="hljs-keyword">impl</span> Affichable <span class="hljs-keyword">for</span> Point {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">afficher</span></span>(&amp;<span class="hljs-keyword">self</span>) {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x = {}, y = {}"</span>, <span class="hljs-keyword">self</span>.x, <span class="hljs-keyword">self</span>.y);
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> point = Point { x: <span class="hljs-number">5</span>, y: <span class="hljs-number">10</span> }; <span class="hljs-comment">// Création d'une instance de la structure Point.</span>
    point.afficher(); <span class="hljs-comment">// Appel de la méthode afficher pour le point.</span>
}
</div></code></pre>
<p>Voyons en détail ce code :</p>
<ul>
<li>trait Affichable { fn afficher(&amp;self); } : définit un trait <code>Affichable</code> avec une méthode <code>afficher</code> qui prend une référence <code>&amp;self</code>.</li>
<li>struct Point { x: i32, y: i32, } : définit une structure <code>Point</code> avec les champs <code>x</code> et <code>y</code>.</li>
<li>impl Affichable for Point { fn afficher(&amp;self) { println!(&quot;x = {}, y = {}&quot;, self.x, self.y); } } : implémente le trait <code>Affichable</code> pour la structure <code>Point</code> en définissant la méthode <code>afficher</code>.</li>
<li>let point = Point { x: 5, y: 10 }; : crée une instance de la structure <code>Point</code>.</li>
<li>point.afficher(); : appelle la méthode <code>afficher</code> pour le point.</li>
<li>x = 5, y = 10 : est le résultat affiché.</li>
</ul>
<h3 id="les-macros">Les macros</h3>
<p>Les macros sont une fonctionnalité de programmation qui permet de définir des fragments de code réutilisables en Rust. Les macros sont utilisées pour générer du code à la compilation et permettent d'écrire du code plus générique et plus flexible. Les macros sont définies à l'aide du mot-clé <code>macro_rules!</code> suivi du nom de la macro et de ses règles de correspondance.</p>
<p>Syntaxe de base des macros en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-built_in">macro_rules!</span> nom_de_la_macro {
    <span class="hljs-comment">// Définition des règles de correspondance de la macro</span>
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-built_in">macro_rules!</span> dire_bonjour {
    () =&gt; {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Bonjour, monde!"</span>);
    };
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    dire_bonjour!(); <span class="hljs-comment">// Appel de la macro dire_bonjour.</span>
}
</div></code></pre>
<p>Voyons en détail ce code :</p>
<ul>
<li>macro_rules! dire_bonjour { () =&gt; { println!(&quot;Bonjour, monde!&quot;); }; } : définit une macro <code>dire_bonjour</code> qui génère le code <code>println!(&quot;Bonjour, monde!&quot;);</code>.</li>
<li>dire_bonjour!(); : appelle la macro <code>dire_bonjour</code> pour générer le code <code>println!(&quot;Bonjour, monde!&quot;);</code>.</li>
<li>le <code>!</code> après le nom de la macro indique qu'il s'agit d'une macro et non d'une fonction.</li>
</ul>
<p>La différence entre une macro et une fonction est que la macro est évaluée à la compilation, tandis que la fonction est évaluée à l'exécution. Les macros sont utilisées pour générer du code à la compilation, ce qui permet d'écrire du code plus générique et plus flexible.</p>
<h2 id="ownership-propri%C3%A9t%C3%A9">Ownership (Propriété)</h2>
<p>L'ownership (propriété) est un concept clé en Rust qui permet de gérer la mémoire de manière sûre et efficace en suivant des règles strictes de propriété, d'emprunt et de retour. L'ownership est un concept clé en Rust qui permet de gérer la mémoire de manière sûre et efficace en suivant des règles strictes de propriété, d'emprunt et de retour. L'ownership garantit que les ressources mémoire sont libérées de manière sûre et évite les problèmes de fuites de mémoire et de corruption de mémoire.</p>
<h3 id="r%C3%A8gles-de-lownership">Règles de l'ownership</h3>
<p>Les règles de l'ownership en Rust sont les suivantes :</p>
<ul>
<li>Chaque valeur en Rust a une variable qui est sa propriétaire.</li>
<li>Une valeur ne peut avoir qu'un seul propriétaire à la fois.</li>
<li>Lorsqu'un propriétaire sort du champ d'application, la valeur est libérée.</li>
<li>La propriété peut être transférée à une autre variable ou empruntée temporairement.</li>
<li>Les emprunts sont des références à une valeur qui n'ont pas la propriété de la valeur.</li>
<li>Les emprunts peuvent être mutables ou immuables.</li>
<li>Les emprunts sont vérifiés à la compilation pour éviter les problèmes de sécurité et de concurrence.</li>
<li>Les emprunts sont libérés lorsque la référence sort du champ d'application.</li>
<li>Les emprunts peuvent être partagés entre plusieurs propriétaires.</li>
</ul>
<h3 id="emprunts-et-r%C3%A9f%C3%A9rences">Emprunts et références</h3>
<p>Les emprunts et les références sont des concepts clés en Rust qui permettent de partager des valeurs entre plusieurs propriétaires sans transférer la propriété de la valeur. Les emprunts et les références sont utilisés pour accéder aux valeurs sans posséder la valeur elle-même, ce qui évite les problèmes de transfert de propriété et de duplication de données.</p>
<ul>
<li><strong>Emprunt</strong> : En Rust, l'emprunt est un concept central qui permet d'accéder à des données sans en prendre possession, assurant ainsi la sécurité de la mémoire et prévenant les erreurs courantes comme les violations d'accès concurrent ou les fuites de mémoire. Voici la syntaxe de base et quelques règles concernant les emprunts en Rust :</li>
</ul>
<p>Emprunts Borrowing (Emprunt immuable) :</p>
<p>Règles des Emprunts Borrowing (Emprunt immuable) :</p>
<ol>
<li>
<p><strong>Durée de vie des emprunts</strong> : Un emprunt ne peut pas outrepasser la durée de vie de la ressource empruntée. Cela garantit qu'un emprunt ne pointe jamais vers une donnée qui a été libérée.</p>
</li>
<li>
<p><strong>Emprunts mutables exclusifs</strong> : Vous ne pouvez pas mélanger des emprunts mutables et immuables d'une même ressource dans une même portée. Rust empêche cela pour éviter des modifications inattendues et des accès concurrents à la même donnée.</p>
</li>
<li>
<p><strong>Non-dangling pointers</strong> : Les règles d'emprunt de Rust assurent que vous ne créez jamais de pointeurs suspendus (dangling pointers) — des pointeurs qui référencent une zone de mémoire qui a été libérée.</p>
</li>
<li>
<p><strong>Pattern Matching &amp; Destructuring</strong> : Vous pouvez utiliser les emprunts dans le pattern matching et le destructuring pour accéder à des parties d'une structure sans en prendre possession.</p>
</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>; <span class="hljs-comment">// Déclaration d'une variable x avec la valeur 5.</span>
    <span class="hljs-keyword">let</span> emprunt = &amp;x; <span class="hljs-comment">// Création d'un emprunt immuable à la valeur de x.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// Affichage de la valeur de x.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de l'emprunt est : {}"</span>, emprunt); <span class="hljs-comment">// Affichage de la valeur de l'emprunt.</span>
}
</div></code></pre>
<p>Dans ce exemple, un emprunt <code>immuable</code> est créé à la valeur de <code>x</code> en utilisant l'opérateur <code>&amp;.</code> Cela signifie que l'emprunt ne possède pas la valeur de x, mais peut y accéder de manière immuable. Cela garantit que la valeur de <code>x</code> ne peut pas être modifiée pendant la durée de vie de l'emprunt.</p>
<p><strong>Emprunt mutables</strong> : Les emprunts mutables permettent de modifier la valeur de la variable à laquelle ils sont empruntés. En Rust, les emprunts mutables sont vérifiés à la compilation pour éviter les problèmes de sécurité et de concurrence.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = <span class="hljs-number">5</span>; <span class="hljs-comment">// Déclaration d'une variable x avec la valeur 5.</span>
    <span class="hljs-keyword">let</span> emprunt = &amp;<span class="hljs-keyword">mut</span> x; <span class="hljs-comment">// Création d'un emprunt mutable à la valeur de x.</span>
    *emprunt += <span class="hljs-number">1</span>; <span class="hljs-comment">// Modification de la valeur de x à travers l'emprunt.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// Affichage de la valeur de x.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de l'emprunt est : {}"</span>, emprunt); <span class="hljs-comment">// Affichage de la valeur de l'emprunt.</span>
}
</div></code></pre>
<p>Voyons en détail ce code :</p>
<ul>
<li><code>let mut x = 5;</code> : déclare une variable <code>x</code> et l'initialise avec la valeur <code>5</code>.</li>
<li>l<code>et emprunt = &amp;mut x;</code> : crée un emprunt mutable à la valeur de <code>x</code>.</li>
<li><code>*emprunt += 1;</code> : modifie la valeur de <code>x</code> à travers l'emprunt.</li>
<li><code>*</code> : est l'opérateur de déréférencement qui permet d'accéder à la valeur de l'emprunt.</li>
<li><code>println!(&quot;La valeur de x est : {}&quot;, x);</code> : affiche la valeur de <code>x</code>.</li>
</ul>
<p>Les règles suivantes s'appliquent aux emprunts mutables :</p>
<ol>
<li>Vous ne pouvez avoir qu'un seul emprunt mutable d'une ressource dans une portée donnée. Cela empêche les conditions de course.</li>
<li>Les emprunts mutables sont exclusifs : si vous avez un emprunt mutable, vous ne pouvez pas avoir d'emprunts immuables en même temps.</li>
</ol>
<ul>
<li><strong>Références</strong> : Les références sont des pointeurs intelligents qui permettent d'accéder à une valeur sans posséder la valeur elle-même. Les références sont utilisées pour partager des valeurs entre plusieurs propriétaires sans transférer la propriété de la valeur.</li>
</ul>
<p>Syntaxe de base des références en Rust :</p>
<p><strong>Références immuables</strong> : Pour créer une référence immuable à une valeur, utilisez le symbole &amp;. Les références immuables permettent de lire une valeur sans la modifier :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>; <span class="hljs-comment">// Déclaration d'une variable x avec la valeur 5.</span>
    <span class="hljs-keyword">let</span> reference = &amp;x; <span class="hljs-comment">// Création d'une référence à la valeur de x.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// Affichage de la valeur de x.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de la référence est : {}"</span>, reference); <span class="hljs-comment">// Affichage de la valeur de la référence.</span>
}
</div></code></pre>
<p><strong>Référence mutables</strong> :Pour créer une référence mutable à une valeur, utilisez &amp;mut. Les références mutables permettent de modifier une valeur :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = <span class="hljs-number">5</span>; <span class="hljs-comment">// Déclaration d'une variable x avec la valeur 5.</span>
    <span class="hljs-keyword">let</span> reference = &amp;<span class="hljs-keyword">mut</span> x; <span class="hljs-comment">// Création d'une référence mutable à la valeur de x.</span>
    *reference += <span class="hljs-number">1</span>; <span class="hljs-comment">// Modification de la valeur de x à travers la référence.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// Affichage de la valeur de x.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de la référence est : {}"</span>, reference); <span class="hljs-comment">// Affichage de la valeur de la référence.</span>
}
</div></code></pre>
<p><strong>Règles importantes</strong></p>
<ol>
<li>
<p>Non-Dualité : Vous ne pouvez pas avoir une référence mutable lorsque vous avez une ou plusieurs références immuables. De même, si vous avez une référence mutable, vous ne pouvez pas créer de références immuables. Cette règle aide à prévenir les conditions de course.</p>
</li>
<li>
<p>Portée des Références : Une référence mutable ne peut exister que dans une portée où aucune autre référence (ni mutable ni immuable) à la même donnée n'existe.</p>
</li>
<li>
<p>Dangling References : Rust garantit qu'une référence ne peut jamais être une référence suspendue (dangling). Cela signifie que les données à laquelle une référence pointe ne seront jamais nettoyées tant que la référence existe.</p>
</li>
<li>
<p>Déréférencement : Utilisez l'opérateur de déréférencement * pour accéder ou modifier la valeur pointée par une référence.</p>
</li>
</ol>
<p><strong>Déréférencement et Modification</strong> : Lorsque vous avez une référence mutable à une valeur, vous pouvez modifier cette valeur en utilisant l'opérateur (<code>*</code>) de déréférencement. Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> x = <span class="hljs-number">5</span>; <span class="hljs-comment">// Déclaration d'une variable x avec la valeur 5.</span>
    <span class="hljs-keyword">let</span> reference = &amp;<span class="hljs-keyword">mut</span> x; <span class="hljs-comment">// Création d'une référence mutable à la valeur de x.</span>
    *reference += <span class="hljs-number">10</span>; <span class="hljs-comment">// Modification de la valeur de x à travers la référence.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de x est : {}"</span>, x); <span class="hljs-comment">// Affichage de la valeur de x.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur de la référence est : {}"</span>, reference); <span class="hljs-comment">// Affichage de la valeur de la référence.</span>
}
</div></code></pre>
<p>Les références, à la fois immuables et mutables, sont fondamentales pour travailler avec le système d'emprunt en Rust, offrant une manière sûre d'accéder et de modifier les données sans prendre possession complète de ces dernières.</p>
<h3 id="slices">Slices</h3>
<p>Les slices sont des vues sur des parties d'un tableau en Rust. Ils permettent d'accéder à des parties d'un tableau sans posséder le tableau lui-même. Les slices sont utilisés pour partager des parties d'un tableau entre plusieurs propriétaires sans transférer la propriété du tableau.</p>
<p>Syntaxe de base des slices en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> tableau = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Déclaration d'un tableau avec des valeurs.</span>
    <span class="hljs-keyword">let</span> slice = &amp;tableau[<span class="hljs-number">1</span>..<span class="hljs-number">4</span>]; <span class="hljs-comment">// Création d'un slice à partir du tableau qui contiendra les éléments 1, 2 et 3.</span>

    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> slice { <span class="hljs-comment">// Pour chaque élément du slice...</span>
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le slice est : {}"</span>, element); <span class="hljs-comment">// Affichage de la valeur de l'élément.</span>
    }
}
</div></code></pre>
<p><strong>Règles Importantes</strong></p>
<ol>
<li>
<p><strong>Sécurité</strong> : Lorsque vous créez un slice, Rust vérifie les indices à la compilation si possible, ou à l'exécution, pour s'assurer qu'ils sont valides et ne débordent pas de la collection. Ceci aide à prévenir les erreurs de segmentation.</p>
</li>
<li>
<p><strong>Immutabilité</strong> : Si la collection d'origine est immuable, le slice est également immuable. Si vous avez une référence mutable vers la collection d'origine et qu'aucun emprunt mutable ou immuable actif n'existe, vous pouvez créer un slice mutable.</p>
</li>
<li>
<p><strong>Durée de vie</strong> : Les slices empruntent les données qu'ils référencent. Par conséquent, la durée de vie d'un slice ne peut pas dépasser celle de la collection à laquelle il se réfère.</p>
</li>
</ol>
<p><strong>Utilisations Courantes</strong></p>
<ol>
<li>
<p><strong>Accès en Lecture</strong> : Les slices sont utilisés pour accéder en lecture à une portion d'une collection sans en prendre possession.</p>
</li>
<li>
<p><strong>Passage de Paramètres</strong> : Ils permettent de passer une séquence d'éléments à une fonction sans lui passer la collection entière.</p>
</li>
<li>
<p><strong>Modèles de Conception</strong> : Les slices facilitent certains modèles de conception, comme le partage de données entre différentes parties d'un programme sans copie ni duplication.</p>
</li>
</ol>
<p>Les slices représentent un outil puissant dans Rust pour la manipulation efficace et sécurisée des séquences de données. Ils illustrent bien l'engagement de Rust envers la sécurité mémoire, la prévention des erreurs d'accès et la performance.</p>
<h3 id="les-cha%C3%AEnes-de-caract%C3%A8res">Les chaînes de caractères</h3>
<p>Les chaînes de caractères sont des types de données qui représentent des séquences de caractères en Rust. Les chaînes de caractères sont utilisées pour stocker et manipuler du texte dans les programmes Rust. Les chaînes de caractères peuvent être créées à l'aide de littéraux de chaînes, de chaînes formatées, de chaînes mutables, etc.</p>
<ul>
<li>Exemple : Gestion d'une chaîne de caractères</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> chaine = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Hello, "</span>); <span class="hljs-comment">// Création d'une chaîne mutable.</span>
    chaine.push_str(<span class="hljs-string">"World!"</span>); <span class="hljs-comment">// Ajout d'une chaîne à la chaîne existante.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, chaine); <span class="hljs-comment">// Affichage de la chaîne.</span>
}
</div></code></pre>
<p>Étudions en détail ce code :</p>
<ul>
<li><code>let mut chaine = String::from(&quot;Hello, &quot;);</code> : crée une chaîne de caractères mutable <code>chaine</code> avec la valeur <code>&quot;Hello, &quot;</code>.</li>
<li><code>chaine.push_str(&quot;World!&quot;);</code> : ajoute la chaîne <code>&quot;World!&quot;</code> à la chaîne existante <code>chaine</code>.</li>
<li>push_str : est une méthode qui ajoute une chaîne à une chaîne existante.</li>
<li><code>println!(&quot;{}&quot;, chaine);</code> : affiche la chaîne <code>chaine</code>.</li>
</ul>
<p>Les chaînes de caractères sont des types de données couramment utilisés en programmation pour stocker et manipuler du texte. En Rust, les chaînes de caractères sont gérées de manière sûre et efficace à l'aide de types de données spéciaux tels que <code>String</code> et <code>&amp;str</code>.</p>
<h2 id="structures-et-%C3%A9num%C3%A9rations--les-types-de-donn%C3%A9es-avanc%C3%A9s">Structures et Énumérations : Les types de données avancés</h2>
<p>Les types de données avancés en Rust comprennent les énumérations, les structures, les tuples, les pointeurs intelligents, les chaînes de caractères, etc. Ces types de données permettent de représenter des données plus complexes et de créer des structures de données plus avancées en Rust.</p>
<h3 id="enum-et-pattern-matching">Enum et pattern matching</h3>
<p>Les énumérations sont des types de données qui permettent de définir un type avec un ensemble fini de valeurs possibles. En Rust, les énumérations sont déclarées à l'aide du mot-clé <code>enum</code> suivi du nom de l'énumération et de ses variantes. Voici un exemple de déclaration d'énumération en Rust :</p>
<p>Syntaxe de base de l'énumération en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">NomEnumeration</span></span> {
        Variante1,
        Variante2,
        Variante3,
        <span class="hljs-comment">// ...</span>
    }

    <span class="hljs-keyword">let</span> nom_variable = NomEnumeration::Variante1;

    <span class="hljs-keyword">match</span> nom_variable {
        NomEnumeration::Variante1 =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La variante est Variante1"</span>),
        NomEnumeration::Variante2 =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La variante est Variante2"</span>),
        NomEnumeration::Variante3 =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La variante est Variante3"</span>),
        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La variante est inconnue"</span>),
    }
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Couleur</span></span> {
        Rouge,
        Vert,
        Bleu,
    }
    <span class="hljs-keyword">let</span> couleur = Couleur::Rouge;

    <span class="hljs-keyword">match</span> couleur {
        Couleur::Rouge =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La couleur est rouge"</span>),
        Couleur::Vert =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La couleur est verte"</span>),
        Couleur::Bleu =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La couleur est bleue"</span>),
        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La couleur est inconnue"</span>),
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>enum Couleur { Rouge, Vert, Bleu, }</code> déclare une énumération <code>Couleur</code> avec les variantes <code>Rouge</code>, <code>Vert</code> et <code>Bleu</code>. Ensuite, <code>let couleur = Couleur::Rouge;</code> crée une instance de l'énumération <code>Couleur</code> avec la variante <code>Rouge</code>.</p>
<h3 id="d%C3%A9finir-et-utiliser-une-structure">Définir et utiliser une structure</h3>
<p>Les structures sont des types de données qui permettent de regrouper plusieurs valeurs sous un seul nom. En Rust, les structures sont déclarées à l'aide du mot-clé <code>struct</code> suivi du nom de la structure et de ses champs. Voici un exemple de déclaration de structure en Rust :</p>
<p>Syntaxe de base de la structure en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NomStructure</span></span> {
        champ1: Type1,
        champ2: Type2,
        champ3: Type3,
        <span class="hljs-comment">// ...</span>
    }
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> {
        x: <span class="hljs-built_in">i32</span>,
        y: <span class="hljs-built_in">i32</span>,
    }
    <span class="hljs-keyword">let</span> point = Point { x: <span class="hljs-number">5</span>, y: <span class="hljs-number">10</span> };

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x = {}"</span>, point.x); <span class="hljs-comment">// x = 5</span>
}
</div></code></pre>
<p>Dans cet exemple, <code>struct Point { x: i32, y: i32, }</code> déclare une structure <code>Point</code> avec les champs <code>x</code> et <code>y</code> de type <code>i32</code>. Ensuite, <code>let point = Point { x: 5, y: 10 };</code> crée une instance de la structure <code>Point</code> avec les valeurs <code>5</code> et <code>10</code> pour les champs <code>x</code> et <code>y</code>.</p>
<h3 id="tuples">Tuples</h3>
<p>Les tuples sont des types de données qui permettent de regrouper plusieurs valeurs sous un seul nom sans avoir à définir une structure. En Rust, les tuples sont déclarés à l'aide de parenthèses et de virgules pour séparer les valeurs. Voici un exemple de déclaration de tuple en Rust :</p>
<p>Syntaxe de base du tuple en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> nom_tuple = (valeur1, valeur2, valeur3);
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> point = (<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);

    <span class="hljs-keyword">let</span> (x, y) = point; <span class="hljs-comment">// Décomposition de tuple</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x = {}"</span>, x); <span class="hljs-comment">// x = 5</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"y = {}"</span>, y); <span class="hljs-comment">// y = 10</span>
}
</div></code></pre>
<p>Dans cet exemple, <code>let point = (5, 10);</code> crée un tuple <code>point</code> avec les valeurs <code>5</code> et <code>10</code>. Ensuite, <code>let (x, y) = point;</code> décompose le tuple <code>point</code> en deux variables <code>x</code> et <code>y</code> avec les valeurs <code>5</code> et <code>10</code>.</p>
<p>Les énumérations, les structures et les tuples sont des types de données avancés en Rust qui permettent de représenter des données plus complexes et de créer des structures de données plus avancées. Ces types de données sont largement utilisés en Rust pour représenter des données structurées et complexes.</p>
<h3 id="m%C3%A9thode-et-champ-associ%C3%A9">Méthode et champ associé</h3>
<p>Les méthodes et les champs associés sont des fonctionnalités avancées en Rust qui permettent de définir des méthodes et des champs qui sont associés à une énumération, une structure ou un trait. Les méthodes et les champs associés sont utilisés pour encapsuler la logique et les données associées à une énumération, une structure ou un trait.</p>
<p>Syntaxe de base des méthodes et des champs associés en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">impl</span> NomStructure {
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">nom_methode</span></span>(&amp;<span class="hljs-keyword">self</span>) {
            <span class="hljs-comment">// ...</span>
        }
    }
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Point</span></span> {
        x: <span class="hljs-built_in">i32</span>,
        y: <span class="hljs-built_in">i32</span>,
    }
    <span class="hljs-keyword">impl</span> Point {
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(x: <span class="hljs-built_in">i32</span>, y: <span class="hljs-built_in">i32</span>) -&gt; Point {
            Point { x, y }
        }
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">afficher</span></span>(&amp;<span class="hljs-keyword">self</span>) {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"x = {}, y = {}"</span>, <span class="hljs-keyword">self</span>.x, <span class="hljs-keyword">self</span>.y);
        }
    }
    <span class="hljs-keyword">let</span> point = Point::new(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);
    point.afficher();
}
</div></code></pre>
<p>Étudions en détail ce code :</p>
<ul>
<li><code>struct Point { x: i32, y: i32, }</code> : déclare une structure <code>Point</code> avec les champs <code>x</code> et <code>y</code> de type <code>i32</code>.</li>
<li><code>impl Point { fn new(x: i32, y: i32) -&gt; Point { Point { x, y } } fn afficher(&amp;self) { println!(&quot;x = {}, y = {}&quot;, self.x, self.y); } }</code> : implémente la structure <code>Point</code> avec une méthode <code>new</code> pour créer une nouvelle instance de <code>Point</code> et une méthode <code>afficher</code> pour afficher les valeurs de <code>x</code> et <code>y</code>.</li>
<li><code>let point = Point::new(5, 10);</code> : crée une instance de la structure <code>Point</code> en utilisant la méthode <code>new</code>.</li>
<li><code>point.afficher();</code> : appelle la méthode <code>afficher</code> pour afficher les valeurs de <code>x</code> et <code>y</code>.</li>
<li><code>x = 5, y = 10</code> : est le résultat affiché.</li>
</ul>
<h3 id="exemple--gestion-d%C3%A9tats-avec-enum">Exemple : Gestion d'états avec enum</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Etat</span></span> {
        Inactif,
        Actif,
        EnPanne,
    }
    <span class="hljs-keyword">impl</span> Etat {
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">afficher</span></span>(&amp;<span class="hljs-keyword">self</span>) {
            <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {
                Etat::Inactif =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"L'appareil est inactif"</span>),
                Etat::Actif =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"L'appareil est actif"</span>),
                Etat::EnPanne =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"L'appareil est en panne"</span>),
            }
        }
    }
    <span class="hljs-keyword">let</span> etat = Etat::Actif;
    etat.afficher();
}
</div></code></pre>
<h1 id="gestion-des-erreurs">Gestion des erreurs</h1>
<p>La gestion des erreurs est une technique utilisée pour gérer les erreurs et les exceptions qui peuvent survenir pendant l'exécution d'un programme. En Rust, la gestion des erreurs est réalisée à l'aide de types de données spéciaux tels que <code>Result</code> et <code>Option</code>, ainsi que des instructions telles que <code>match</code>, <code>if let</code>, <code>unwrap</code>, <code>expect</code>, <code>?</code>, etc. Ces types de données et instructions permettent de gérer les erreurs de manière sûre et explicite, en évitant les exceptions non contrôlées.</p>
<h2 id="result-et-option">Result et Option</h2>
<p>Les types de données pour la gestion des erreurs sont des types spéciaux qui permettent de représenter les résultats réussis ou les erreurs qui peuvent survenir pendant l'exécution d'un programme. En Rust, les types de données les plus couramment utilisés pour la gestion des erreurs sont <code>Result</code> et <code>Option</code>.</p>
<h3 id="resultt-e"><code>Result&lt;T, E&gt;</code></h3>
<p>Le type <code>Result</code> est utilisé pour représenter un résultat réussi (<code>Ok</code>) ou une erreur (<code>Err</code>).
<code>&lt;&gt;</code> : Les crochets angulaires sont utilisés pour spécifier les types de données génériques <code>T</code> et <code>E</code>.
<code>T</code> est le type de la valeur réussie et <code>E</code> est le type de l'erreur. <code>Result</code> est souvent utilisé pour les opérations qui peuvent échouer, telles que l'ouverture de fichiers, la lecture de données, etc.</p>
<p>Syntaxe de base du type <code>Result</code> en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> result: <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">i32</span>, &amp;<span class="hljs-built_in">str</span>&gt; = <span class="hljs-literal">Ok</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// Un résultat réussi de type i32</span>
    <span class="hljs-keyword">let</span> error: <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">i32</span>, &amp;<span class="hljs-built_in">str</span>&gt; = <span class="hljs-literal">Err</span>(<span class="hljs-string">"Erreur"</span>); <span class="hljs-comment">// Une erreur de type &amp;str</span>
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">divide</span></span>(x: <span class="hljs-built_in">i32</span>, y: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">i32</span>, &amp;<span class="hljs-built_in">str</span>&gt; {
    <span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span> {
        <span class="hljs-literal">Err</span>(<span class="hljs-string">"Division par zéro"</span>)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-literal">Ok</span>(x / y)
    }
}
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> result = divide(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>);
    <span class="hljs-keyword">match</span> result {
        <span class="hljs-literal">Ok</span>(value) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le résultat est : {}"</span>, value),
        <span class="hljs-literal">Err</span>(error) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Erreur : {}"</span>, error),
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>divide(10, 2)</code> renvoie un résultat réussi <code>Ok(5)</code> si la division est réussie, sinon il renvoie une erreur <code>Err(&quot;Division par zéro&quot;)</code>. Ensuite, <code>match result { Ok(value) =&gt; println!(&quot;Le résultat est : {}&quot;, value), Err(error) =&gt; println!(&quot;Erreur : {}&quot;, error), }</code> affiche le résultat réussi ou l'erreur en fonction du résultat de la division.</p>
<ul>
<li>fn divide(x: i32, y: i32) -&gt; Result&lt;i32, &amp;str&gt; { ... } : déclare une fonction <code>divide</code> qui prend deux paramètres <code>x</code> et <code>y</code> de type <code>i32</code> et renvoie un résultat réussi de type <code>i32</code> ou une erreur de type <code>&amp;str</code>.</li>
<li>if y == 0 { Err(&quot;Division par zéro&quot;) } else { Ok(x / y) } : renvoie une erreur si <code>y</code> est égal à <code>0</code>, sinon renvoie le résultat de la division.</li>
<li>let result = divide(10, 2); : appelle la fonction <code>divide</code> avec les paramètres <code>10</code> et <code>2</code> et stocke le résultat dans la variable <code>result</code>.</li>
<li>match result { Ok(value) =&gt; println!(&quot;Le résultat est : {}&quot;, value), Err(error) =&gt; println!(&quot;Erreur : {}&quot;, error), } : affiche le résultat réussi ou l'erreur en fonction du résultat de la division.</li>
</ul>
<h3 id="optiont"><code>Option&lt;T&gt;</code></h3>
<p>Le type <code>Option</code> est utilisé pour représenter une valeur réussie (<code>Some</code>) ou l'absence de valeur (<code>None</code>).</p>
<p>Syntaxe de base du type <code>Option</code> en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> some_value: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-literal">Some</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// Une valeur réussie de type i32</span>
    <span class="hljs-keyword">let</span> none_value: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-literal">None</span>; <span class="hljs-comment">// L'absence de valeur</span>
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-comment">/**
 * Dans ce bloc de code get_first_element() est une fonction qui prend un tableau de nombres et renvoie le premier élément du tableau s'il existe, sinon elle renvoie l'absence de valeur.
 * get_first_element(&amp;numbers) : appelle la fonction get_first_element() avec un tableau de nombres et stocke le résultat dans la variable first_element.
 * match first_element { Some(value) =&gt; println!("Le premier élément est : {}", value), None =&gt; println!("Aucun élément trouvé"), } : affiche le premier élément si une valeur est réussie, sinon affiche l'absence de valeur.
 */</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_first_element</span></span>(numbers: &amp;[<span class="hljs-built_in">i32</span>]) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i32</span>&gt; {
    <span class="hljs-keyword">if</span> numbers.len() &gt; <span class="hljs-number">0</span> {
        <span class="hljs-literal">Some</span>(numbers[<span class="hljs-number">0</span>]) <span class="hljs-comment">// Une valeur réussie</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-literal">None</span> <span class="hljs-comment">// L'absence de valeur</span>
    }
}
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
    <span class="hljs-keyword">let</span> first_element = get_first_element(&amp;numbers);
    <span class="hljs-keyword">match</span> first_element {
        <span class="hljs-literal">Some</span>(value) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le premier élément est : {}"</span>, value),
        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Aucun élément trouvé"</span>),
    }
}
</div></code></pre>
<p>Étudions en détail ce code :</p>
<ul>
<li><code>fn get_first_element(numbers: &amp;[i32]) -&gt; Option&lt;i32&gt; { ... }</code> : déclare une fonction <code>get_first_element</code> qui prend un tableau de nombres et renvoie une valeur réussie de type <code>i32</code> ou l'absence de valeur.</li>
<li><code>if numbers.len() &gt; 0 { Some(numbers[0]) } else { None }</code> : renvoie une valeur réussie si le tableau de nombres n'est pas vide, sinon renvoie l'absence de valeur.</li>
<li><code>let first_element = get_first_element(&amp;numbers);</code> : appelle la fonction <code>get_first_element</code> avec un tableau de nombres et stocke le résultat dans la variable <code>first_element</code>.</li>
<li><code>match first_element { Some(value) =&gt; println!(&quot;Le premier élément est : {}&quot;, value), None =&gt; println!(&quot;Aucun élément trouvé&quot;), }</code> : affiche le premier élément si une valeur est réussie, sinon affiche l'absence de valeur.</li>
<li><code>Le premier élément est : 1</code> : est le résultat affiché.</li>
<li><code>Aucun élément trouvé</code> : est le résultat affiché.</li>
<li><code>Some(value)</code> : est utilisé pour représenter une valeur réussie.</li>
<li><code>None</code> : est utilisé pour représenter l'absence de valeur.</li>
</ul>
<p>Les types de données <code>Result</code> et <code>Option</code> sont largement utilisés en Rust pour représenter les résultats réussis ou les erreurs, ainsi que les valeurs réussies ou l'absence de valeur. Ces types de données permettent de gérer les erreurs de manière sûre et explicite, en évitant les exceptions non contrôlées.</p>
<h3 id="propagation-des-erreurs">Propagation des erreurs</h3>
<p>La propagation des erreurs est une technique utilisée pour propager les erreurs d'une fonction à une autre fonction qui l'appelle. En Rust, la propagation des erreurs est réalisée à l'aide de l'opérateur <code>?</code> qui permet de propager les erreurs d'une fonction à une autre fonction.</p>
<p>Syntaxe de base de la propagation des erreurs en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fonction1</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">i32</span>, &amp;<span class="hljs-built_in">str</span>&gt; {
        <span class="hljs-literal">Ok</span>(<span class="hljs-number">5</span>)
    }
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">fonction2</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">i32</span>, &amp;<span class="hljs-built_in">str</span>&gt; {
        <span class="hljs-keyword">let</span> resultat = fonction1()?;
        <span class="hljs-literal">Ok</span>(resultat)
    }
}
</div></code></pre>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">divide</span></span>(x: <span class="hljs-built_in">i32</span>, y: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">i32</span>, &amp;<span class="hljs-built_in">str</span>&gt; {
    <span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span> {
        <span class="hljs-literal">Err</span>(<span class="hljs-string">"Division par zéro"</span>)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-literal">Ok</span>(x / y)
    }
}
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">multiply</span></span>(x: <span class="hljs-built_in">i32</span>, y: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">i32</span>, &amp;<span class="hljs-built_in">str</span>&gt; {
    <span class="hljs-keyword">let</span> result = divide(x, y)?;
    <span class="hljs-literal">Ok</span>(result * <span class="hljs-number">2</span>)
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> result = multiply(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>);
    <span class="hljs-keyword">match</span> result {
        <span class="hljs-literal">Ok</span>(value) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le résultat est : {}"</span>, value),
        <span class="hljs-literal">Err</span>(error) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Erreur : {}"</span>, error),
    }
}
</div></code></pre>
<p>Dans cet exemple, <code>multiply(10, 2)</code> appelle la fonction <code>divide</code> pour diviser <code>10</code> par <code>2</code> et stocke le résultat dans la variable <code>result</code>. Ensuite, <code>match result { Ok(value) =&gt; println!(&quot;Le résultat est : {}&quot;, value), Err(error) =&gt; println!(&quot;Erreur : {}&quot;, error), }</code> affiche le résultat réussi ou l'erreur en fonction du résultat de la multiplication.</p>
<ul>
<li><code>fn divide(x: i32, y: i32) -&gt; Result&lt;i32, &amp;str&gt; { ... }</code> : déclare une fonction <code>divide</code> qui prend deux paramètres <code>x</code> et <code>y</code> de type <code>i32</code> et renvoie un résultat réussi de type <code>i32</code> ou une erreur de type <code>&amp;str</code>.</li>
<li><code>if y == 0 { Err(&quot;Division par zéro&quot;) } else { Ok(x / y) }</code> : renvoie une erreur si <code>y</code> est égal à <code>0</code>, sinon renvoie le résultat de la division.</li>
<li><code>fn multiply(x: i32, y: i32) -&gt; Result&lt;i32, &amp;str&gt; { let result = divide(x, y)?; Ok(result * 2) }</code> : appelle la fonction <code>divide</code> pour diviser <code>x</code> par <code>y</code> et stocke le résultat dans la variable <code>result</code>, puis multiplie le résultat par <code>2</code> et renvoie le résultat réussi ou l'erreur.</li>
<li><code>let result = multiply(10, 2);</code> : appelle la fonction <code>multiply</code> avec les paramètres <code>10</code> et <code>2</code> et stocke le résultat dans la variable <code>result</code>.</li>
<li><code>match result { Ok(value) =&gt; println!(&quot;Le résultat est : {}&quot;, value), Err(error) =&gt; println!(&quot;Erreur : {}&quot;, error), }</code> : affiche le résultat réussi ou l'erreur en fonction du résultat de la multiplication.</li>
</ul>
<h3 id="exemple--lecture-dun-fichier-et-gestion-des-erreurs">Exemple : Lecture d'un fichier et gestion des erreurs</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> std::fs::File;
<span class="hljs-keyword">use</span> std::io::Read;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">lire_fichier</span></span>(nom_fichier: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">String</span>, std::io::Error&gt; {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> fichier = File::open(nom_fichier)?;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> contenu = <span class="hljs-built_in">String</span>::new();
    fichier.read_to_string(&amp;<span class="hljs-keyword">mut</span> contenu)?;
    <span class="hljs-literal">Ok</span>(contenu)
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> contenu = lire_fichier(<span class="hljs-string">"fichier.txt"</span>);
    <span class="hljs-keyword">match</span> contenu {
        <span class="hljs-literal">Ok</span>(valeur) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le contenu du fichier est : {}"</span>, valeur),
        <span class="hljs-literal">Err</span>(erreur) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Erreur : {}"</span>, erreur),
    }
}
</div></code></pre>
<p>Que fait ce script :</p>
<ul>
<li><code>use std::fs::File;</code> : importe le module <code>File</code> du module standard <code>fs</code> pour ouvrir et lire un fichier.</li>
<li><code>use std::io::Read;</code> : importe le trait <code>Read</code> du module standard <code>io</code> pour lire le contenu du fichier.</li>
<li><code>fn lire_fichier(nom_fichier: &amp;str) -&gt; Result&lt;String, std::io::Error&gt; { ... }</code> : déclare une fonction <code>lire_fichier</code> qui prend le nom du fichier à lire et renvoie le contenu du fichier ou une erreur.</li>
<li><code>let mut fichier = File::open(nom_fichier)?;</code> : ouvre le fichier spécifié et stocke le résultat dans la variable <code>fichier</code>, en propageant l'erreur si le fichier n'existe pas.</li>
<li><code>fichier.read_to_string(&amp;mut contenu)?;</code> : lit le contenu du fichier et stocke le résultat dans la variable <code>contenu</code>, en propageant l'erreur si la lecture échoue.</li>
<li><code>Ok(contenu)</code> : renvoie le contenu du fichier ou une erreur.</li>
<li><code>let contenu = lire_fichier(&quot;fichier.txt&quot;);</code> : appelle la fonction <code>lire_fichier</code> avec le nom du fichier à lire et stocke le résultat dans la variable <code>contenu</code>.</li>
<li><code>match contenu { Ok(valeur) =&gt; println!(&quot;Le contenu du fichier est : {}&quot;, valeur), Err(erreur) =&gt; println!(&quot;Erreur : {}&quot;, erreur), }</code> : affiche le contenu du fichier si la lecture réussit, sinon affiche l'erreur.</li>
<li><code>Le contenu du fichier est : ...</code> : est le résultat affiché si la lecture réussit.</li>
<li><code>Erreur : ...</code> : est le résultat affiché si la lecture échoue.</li>
</ul>
<p>Ce script lit le contenu d'un fichier spécifié et affiche le contenu du fichier si la lecture réussit, sinon affiche l'erreur.</p>
<h3 id="gestion-des-erreurs-avec--et-unwrap">Gestion des erreurs avec <code>?</code> et <code>unwrap</code></h3>
<h4 id="lop%C3%A9rateur">L'opérateur <code>?</code></h4>
<p>est utilisé pour propager les erreurs d'une fonction à une autre fonction, tandis que la méthode <code>unwrap</code> est utilisée pour extraire la valeur réussie d'un résultat ou provoquer une panique si une erreur se produit.</p>
<p>Syntaxe de base de l'opérateur <code>?</code> et de la méthode <code>unwrap</code> en Rust :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> result = fonction()?; <span class="hljs-comment">// Propagation des erreurs avec l'opérateur ?</span>
    <span class="hljs-keyword">let</span> value = result.unwrap(); <span class="hljs-comment">// Extraction de la valeur réussie avec la méthode unwrap</span>
}
</div></code></pre>
<h4 id="unwrap--est-une-m%C3%A9thode-qui-extrait-la-valeur-r%C3%A9ussie-dun-r%C3%A9sultat-ou-provoque-une-panique-si-une-erreur-se-produit"><code>unwrap</code> : est une méthode qui extrait la valeur réussie d'un résultat ou provoque une panique si une erreur se produit</h4>
<p>Exemple :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">divide</span></span>(x: <span class="hljs-built_in">i32</span>, y: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">i32</span>, &amp;<span class="hljs-built_in">str</span>&gt; {
    <span class="hljs-keyword">if</span> y == <span class="hljs-number">0</span> {
        <span class="hljs-literal">Err</span>(<span class="hljs-string">"Division par zéro"</span>)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-literal">Ok</span>(x / y)
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> result = divide(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)?;
    <span class="hljs-keyword">let</span> value = result.unwrap();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le résultat est : {}"</span>, value);
}
</div></code></pre>
<h1 id="rust-dans-la-pratique">Rust dans la Pratique</h1>
<h2 id="collections">Collections</h2>
<p>Les collections sont des types de données qui permettent de stocker et de manipuler des ensembles de valeurs dans un programme. En Rust, les collections les plus couramment utilisées sont les vecteurs, les chaînes de caractères et les hachages. Ces collections offrent des fonctionnalités avancées pour stocker, accéder, modifier et parcourir des ensembles de valeurs.</p>
<h3 id="vecteurs-string-et-hashmap">Vecteurs, String et HashMap</h3>
<p>Les vecteurs, les chaînes de caractères et les hachages sont des types de données couramment utilisés en Rust pour stocker et manipuler des ensembles de valeurs.</p>
<h4 id="vecteurs">Vecteurs</h4>
<p>Les vecteurs en Rust sont des collections homogènes qui stockent leurs éléments dans un espace contigu de la mémoire. Ils peuvent croître ou décroître dynamiquement, ce qui les rend très flexibles pour stocker une collection d'éléments qui peut varier en taille. Un vecteur est représenté par le type <code>Vec&lt;T&gt;</code>, où <code>T</code> est le type des éléments qu'il contient. Voici une introduction à l'utilisation et à la manipulation des vecteurs en Rust.</p>
<p><strong>Création d'un Vecteur</strong></p>
<p>Pour créer un nouveau vecteur vide, vous pouvez utiliser Vec::new() ou la macro vec! pour créer un vecteur avec des éléments initiaux :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur_vide: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-built_in">Vec</span>::new(); <span class="hljs-comment">// Création d'un vecteur vide.</span>
    <span class="hljs-keyword">let</span> vecteur_initial = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs initiales.</span>
}
</div></code></pre>
<p>Voyons les détails de ce code :</p>
<ul>
<li><code>Vec&lt;i32&gt;</code> : est le type de données du vecteur qui stocke des entiers 32 bits.</li>
<li><code>let mut vecteur_vide: Vec&lt;i32&gt; = Vec::new();</code> : crée un nouveau vecteur vide de type <code>i32</code>.</li>
<li><code>let vecteur_initial = vec![1, 2, 3, 4, 5];</code> : crée un vecteur avec des valeurs initiales <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code> et <code>5</code>.</li>
<li><code>vec![]</code> : est une macro qui crée un vecteur avec des valeurs initiales.</li>
<li><code>!</code> : est utilisé pour appeler une macro.</li>
</ul>
<p><strong>Modification et Accès aux Éléments</strong></p>
<p><strong>Modification</strong></p>
<p>Vous pouvez ajouter des éléments à un vecteur en utilisant la méthode <strong>push</strong> :</p>
<ul>
<li><strong>push</strong> : ajoute un élément à la fin du vecteur.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    vecteur.push(<span class="hljs-number">6</span>); <span class="hljs-comment">// Ajout d'une valeur au vecteur.</span>

    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> &amp;vecteur { <span class="hljs-comment">// Pour chaque élément du vecteur...</span>
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le vecteur est : {}"</span>, element); <span class="hljs-comment">// Affichage de la valeur de l'élément.</span>
    }
}
</div></code></pre>
<ul>
<li><strong>pop</strong> : Supprime et retourne le dernier élément du vecteur, s'il existe..</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> dernier_element = vecteur.pop(); <span class="hljs-comment">// Suppression du dernier élément du vecteur.</span>

    <span class="hljs-keyword">match</span> dernier_element {
        <span class="hljs-literal">Some</span>(valeur) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le dernier élément est : {}"</span>, valeur),
        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Aucun élément trouvé"</span>),
    }
}
</div></code></pre>
<ul>
<li><strong>insert(index, element)</strong> : Insère un élément à une position donnée dans le vecteur..</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    vecteur.insert(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>); <span class="hljs-comment">// Insertion de la valeur 6 à l'index 2.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, vecteur); <span class="hljs-comment">// Affichage du vecteur.</span>
}
</div></code></pre>
<ul>
<li><strong>remove(index)</strong> : Supprime et retourne l'élément à la position donnée.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> element = vecteur.remove(<span class="hljs-number">2</span>); <span class="hljs-comment">// Suppression de l'élément à l'index 2.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"L'élément supprimé est : {}"</span>, element); <span class="hljs-comment">// Affichage de la valeur de l'élément supprimé.</span>
}
</div></code></pre>
<ul>
<li><strong>reverse</strong> : inverse les éléments du vecteur.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    vecteur.reverse(); <span class="hljs-comment">// Inversion des éléments du vecteur.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, vecteur); <span class="hljs-comment">// Affichage du vecteur inversé.</span>
}
</div></code></pre>
<ul>
<li><strong>append</strong> : ajoute les éléments d'un autre vecteur à la fin du vecteur.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur1 = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> vecteur2 = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]; <span class="hljs-comment">// Création d'un autre vecteur avec des valeurs.</span>
    vecteur1.append(&amp;<span class="hljs-keyword">mut</span> vecteur2); <span class="hljs-comment">// Ajout des éléments du vecteur2 au vecteur1.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, vecteur1); <span class="hljs-comment">// Affichage du vecteur1.</span>
}
</div></code></pre>
<ul>
<li><strong>extend</strong> : ajoute les éléments d'un itérable à la fin du vecteur. Cela peut être un autre vecteur, une tranche, une chaîne de caractères, etc.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> tableau = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]; <span class="hljs-comment">// Création d'un tableau avec des valeurs.</span>
    vecteur.extend(&amp;tableau); <span class="hljs-comment">// Ajout des éléments du tableau au vecteur.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, vecteur); <span class="hljs-comment">// Affichage du vecteur.</span>
}
</div></code></pre>
<ul>
<li><strong>dedup</strong> : supprime les éléments en double du vecteur.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    vecteur.dedup(); <span class="hljs-comment">// Suppression des doublons.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, vecteur); <span class="hljs-comment">// Affichage du vecteur.</span>
}
</div></code></pre>
<ul>
<li><strong>resize</strong> : redimensionne le vecteur pour contenir le nombre spécifié d'éléments.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    vecteur.resize(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// Redimensionnement du vecteur pour contenir 10 éléments avec la valeur 0.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, vecteur); <span class="hljs-comment">// Affichage du vecteur.</span>
}
</div></code></pre>
<ul>
<li><strong>truncate</strong> : tronque le vecteur pour contenir le nombre spécifié d'éléments. Cela supprime les éléments supplémentaires.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    vecteur.truncate(<span class="hljs-number">3</span>); <span class="hljs-comment">// Troncature du vecteur pour contenir 3 éléments.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, vecteur); <span class="hljs-comment">// Affichage du vecteur.</span>
}
</div></code></pre>
<p><strong>Accès aux Éléments</strong></p>
<ul>
<li><strong>get(index)</strong> : Retourne une option contenant une référence à l'élément à une position donnée.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> element = vecteur.get(<span class="hljs-number">2</span>); <span class="hljs-comment">// Récupération de l'élément à l'index 2.</span>

    <span class="hljs-keyword">match</span> element {
        <span class="hljs-literal">Some</span>(valeur) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"L'élément est : {}"</span>, valeur), <span class="hljs-comment">// Affichage de la valeur de l'élément.</span>
        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Aucun élément trouvé"</span>), <span class="hljs-comment">// Affichage si aucun élément n'est trouvé.</span>
    }
}
</div></code></pre>
<ul>
<li><strong>first() / last()</strong> : Retourne une option contenant une référence au premier / dernier élément.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> premier = vecteur.first(); <span class="hljs-comment">// Récupération du premier élément.</span>
    <span class="hljs-keyword">let</span> dernier = vecteur.last(); <span class="hljs-comment">// Récupération du dernier élément.</span>

    <span class="hljs-keyword">match</span> premier {
        <span class="hljs-literal">Some</span>(valeur) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le premier élément est : {}"</span>, valeur), <span class="hljs-comment">// Affichage de la valeur du premier élément.</span>
        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Aucun élément trouvé"</span>), <span class="hljs-comment">// Affichage si aucun élément n'est trouvé.</span>
    }

    <span class="hljs-keyword">match</span> dernier {
        <span class="hljs-literal">Some</span>(valeur) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le dernier élément est : {}"</span>, valeur), <span class="hljs-comment">// Affichage de la valeur du dernier élément.</span>
        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Aucun élément trouvé"</span>), <span class="hljs-comment">// Affichage si aucun élément n'est trouvé.</span>
    }
}
</div></code></pre>
<p><strong>Itération sur les éléments</strong></p>
<ul>
<li><strong>iter</strong> : renvoie un itérateur sur les éléments du vecteur.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>

    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> vecteur.iter() { <span class="hljs-comment">// Pour chaque élément du vecteur...</span>
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le vecteur est : {}"</span>, element); <span class="hljs-comment">// Affichage de la valeur de l'élément.</span>
    }
}
</div></code></pre>
<ul>
<li><strong>iter_mut</strong> : renvoie un itérateur mutable sur les éléments du vecteur. Cela permet de modifier les éléments du vecteur pendant l'itération.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>

    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> vecteur.iter_mut() { <span class="hljs-comment">// Pour chaque élément mutable du vecteur...</span>
        *element += <span class="hljs-number">1</span>; <span class="hljs-comment">// Incrémentation de la valeur de l'élément.</span>
    }

    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> &amp;vecteur { <span class="hljs-comment">// Pour chaque élément du vecteur...</span>
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le vecteur est : {}"</span>, element); <span class="hljs-comment">// Affichage de la valeur de l'élément.</span>
    }
}
</div></code></pre>
<ul>
<li><strong>into_iter</strong> : consomme le vecteur et renvoie un itérateur sur ses éléments. Cela signifie que le vecteur n'est plus utilisable après l'appel de cette méthode.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>

    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> vecteur.into_iter() { <span class="hljs-comment">// Pour chaque élément du vecteur...</span>
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le vecteur est : {}"</span>, element); <span class="hljs-comment">// Affichage de la valeur de l'élément.</span>
    }
}
</div></code></pre>
<p><strong>Recherche et Sélection d'Éléments</strong></p>
<ul>
<li><strong>contains(element)</strong> : Vérifie si le vecteur contient un élément donné.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> contient = vecteur.contains(&amp;<span class="hljs-number">3</span>); <span class="hljs-comment">// Vérification si le vecteur contient la valeur 3.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le vecteur contient la valeur 3 : {}"</span>, contient); <span class="hljs-comment">// Affichage si le vecteur contient la valeur 3 ou non.</span>
}
</div></code></pre>
<ul>
<li><strong>sort() / sort_by(key)</strong> : Trie les éléments du vecteur en place, éventuellement avec une fonction de tri personnalisée.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    vecteur.sort(); <span class="hljs-comment">// Tri des éléments du vecteur.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, vecteur); <span class="hljs-comment">// Affichage du vecteur trié.</span>
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    vecteur.sort_by(|a, b| b.cmp(a)); <span class="hljs-comment">// Tri des éléments du vecteur dans l'ordre inverse.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, vecteur); <span class="hljs-comment">// Affichage du vecteur trié dans l'ordre inverse.</span>
}
</div></code></pre>
<p>Voyons ce code en détail :</p>
<ul>
<li>
<p><code>|a, b| b.cmp(a)</code> : est une fonction de tri personnalisée qui trie les éléments dans l'ordre inverse.</p>
</li>
<li>
<p><code>b.cmp(a)</code> : compare les éléments <code>a</code> et <code>b</code> dans l'ordre inverse.</p>
</li>
<li>
<p><code>cmp</code> : est une méthode de comparaison qui renvoie un ordre de tri pour deux éléments.</p>
</li>
<li>
<p><code>vecteur.sort_by(|a, b| b.cmp(a))</code> : trie les éléments du vecteur dans l'ordre inverse.</p>
</li>
<li>
<p><strong>binary_search_by</strong> : recherche un élément dans le vecteur en utilisant un prédicat spécifié et renvoie son index.</p>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> index = vecteur.binary_search_by(|element| element.cmp(&amp;<span class="hljs-number">3</span>)); <span class="hljs-comment">// Recherche de la valeur 3 dans le vecteur.</span>

    <span class="hljs-keyword">match</span> index {
        <span class="hljs-literal">Ok</span>(i) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur 3 est à l'index : {}"</span>, i), <span class="hljs-comment">// Affichage de l'index de la valeur 3.</span>
        <span class="hljs-literal">Err</span>(_) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur 3 n'est pas trouvée"</span>), <span class="hljs-comment">// Affichage si la valeur 3 n'est pas trouvée.</span>
    }
}
</div></code></pre>
<ul>
<li><strong>binary_search_by_key</strong> : recherche un élément dans le vecteur en utilisant une clé spécifiée et renvoie son index.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">"un"</span>, <span class="hljs-string">"deux"</span>, <span class="hljs-string">"trois"</span>, <span class="hljs-string">"quatre"</span>, <span class="hljs-string">"cinq"</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> index = vecteur.binary_search_by_key(&amp;<span class="hljs-string">"quatre"</span>, |element| element.len()); <span class="hljs-comment">// Recherche de la valeur "quatre" dans le vecteur.</span>

    <span class="hljs-keyword">match</span> index {
        <span class="hljs-literal">Ok</span>(i) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur 'quatre' est à l'index : {}"</span>, i), <span class="hljs-comment">// Affichage de l'index de la valeur "quatre".</span>
        <span class="hljs-literal">Err</span>(_) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur 'quatre' n'est pas trouvée"</span>), <span class="hljs-comment">// Affichage si la valeur "quatre" n'est pas trouvée.</span>
    }
}
</div></code></pre>
<ul>
<li><strong>binary_search(element)</strong> : Recherche un élément donné dans le vecteur et renvoie l'index de l'élément s'il est trouvé.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> index = vecteur.binary_search(&amp;<span class="hljs-number">3</span>); <span class="hljs-comment">// Recherche de la valeur 3 dans le vecteur.</span>

    <span class="hljs-keyword">match</span> index {
        <span class="hljs-literal">Ok</span>(i) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur 3 est à l'index : {}"</span>, i), <span class="hljs-comment">// Affichage de l'index de la valeur 3.</span>
        <span class="hljs-literal">Err</span>(_) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La valeur 3 n'est pas trouvée"</span>), <span class="hljs-comment">// Affichage si la valeur 3 n'est pas trouvée.</span>
    }
}
</div></code></pre>
<p><strong>Gestion des Collections Clé-Valeur</strong></p>
<ul>
<li><strong>contains_key</strong> : renvoie vrai si le vecteur contient la clé spécifiée, sinon faux. (Note : Cette méthode est généralement utilisée avec les hashmaps, pas les vecteurs.)</li>
</ul>
<p>En Rust, la méthode <code>contains_key</code> est spécifique aux types de collections qui gèrent des paires clé-valeur, comme les <code>HashMap</code> ou les <code>BTreeMap</code>, et non aux vecteurs (<code>Vec&lt;T&gt;</code>). Les vecteurs ne possèdent pas de méthode <code>contains_key</code> car ils sont des collections indexées par des positions numériques, pas par des clés.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> std::collections::HashMap;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> hashmap = std::collections::HashMap::new(); <span class="hljs-comment">// Création d'une nouvelle hashmap.</span>
    hashmap.insert(<span class="hljs-string">"un"</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// Ajout d'une paire clé-valeur à la hashmap.</span>
    hashmap.insert(<span class="hljs-string">"deux"</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// Ajout d'une autre paire clé-valeur à la hashmap.</span>

    <span class="hljs-keyword">let</span> contient = hashmap.contains_key(<span class="hljs-string">"un"</span>); <span class="hljs-comment">// Vérification si la hashmap contient la clé "un".</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La hashmap contient la clé 'un' : {}"</span>, contient); <span class="hljs-comment">// Affichage si la hashmap contient la clé "un" ou non.</span>
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> std::collections::HashMap;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scores = HashMap::new();

  scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Bleu"</span>), <span class="hljs-number">10</span>);
  scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Rouge"</span>), <span class="hljs-number">50</span>);

  <span class="hljs-comment">// Vérifie si la clé "Bleu" existe dans le HashMap</span>
  <span class="hljs-keyword">if</span> scores.contains_key(<span class="hljs-string">"Bleu"</span>) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La score pour l'équipe Bleu est présent."</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Aucun score trouvé pour l'équipe Bleu."</span>);
  }

  <span class="hljs-comment">// Vérifie si la clé "Vert" existe</span>
  <span class="hljs-keyword">if</span> scores.contains_key(<span class="hljs-string">"Vert"</span>) {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La score pour l'équipe Vert est présent."</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Aucun score trouvé pour l'équipe Vert."</span>);
  }
}
</div></code></pre>
<p>Dans cet exemple :</p>
<ul>
<li>Un <code>HashMap</code>nommé <code>scores</code> est créé et rempli avec des scores pour deux équipes, <code>&quot;Bleu&quot;</code> et <code>&quot;Rouge&quot;</code>.</li>
<li>La méthode <code>contains_key</code> est utilisée pour vérifier si une clé spécifique (&quot;Bleu&quot; ou &quot;Vert&quot;) existe dans le <code>HashMap</code>.</li>
<li><code>contains_key</code> renvoie <code>true</code> si la clé est présente dans le <code>HashMap</code>, et <code>false</code> dans le cas contraire.</li>
<li>L'utilisation de <code>contains_key</code> est donc pertinente dans des contextes où vous devez vérifier l'existence d'une clé spécifique dans un <code>HashMap</code> ou un <code>BTreeMap</code>, ce qui est utile pour éviter les doublons ou pour décider si une opération spécifique doit être effectuée en fonction de la présence ou non d'une clé.</li>
</ul>
<p>Ce que sont les HashMap et les BTreeMap, et comment les utiliser, sera abordé dans un autre chapitre.</p>
<p><strong>Taille et Capacité</strong></p>
<ul>
<li><strong>len</strong> : renvoie le nombre d'éléments dans le vecteur.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> taille = vecteur.len(); <span class="hljs-comment">// Récupération de la taille du vecteur.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La taille du vecteur est : {}"</span>, taille); <span class="hljs-comment">// Affichage de la taille du vecteur.</span>
}
</div></code></pre>
<ul>
<li><strong>capacity</strong> : renvoie la capacité du vecteur. La capacité est le nombre d'éléments que le vecteur peut contenir sans allouer de nouveau stockage.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> capacite = vecteur.capacity(); <span class="hljs-comment">// Récupération de la capacité du vecteur.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"La capacité du vecteur est : {}"</span>, capacite); <span class="hljs-comment">// Affichage de la capacité du vecteur.</span>
}
</div></code></pre>
<ul>
<li><strong>clear</strong> : supprime tous les éléments du vecteur.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    vecteur.clear(); <span class="hljs-comment">// Suppression de tous les éléments du vecteur.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, vecteur); <span class="hljs-comment">// Affichage du vecteur.</span>
}
</div></code></pre>
<p><strong>Accès Bas-Niveau aux Éléments</strong></p>
<ul>
<li><strong>as_slice</strong> : renvoie une tranche contenant une vue sur les éléments du vecteur.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> tranche = vecteur.as_slice(); <span class="hljs-comment">// Récupération d'une tranche contenant une vue sur les éléments du vecteur.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, tranche); <span class="hljs-comment">// Affichage de la tranche.</span>
}
</div></code></pre>
<ul>
<li><strong>as_ptr</strong> : renvoie un pointeur vers les éléments du vecteur.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> pointeur = vecteur.as_ptr(); <span class="hljs-comment">// Récupération du pointeur vers les éléments du vecteur.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le pointeur du vecteur est : {:?}"</span>, pointeur); <span class="hljs-comment">// Affichage du pointeur du vecteur.</span>
}
</div></code></pre>
<ul>
<li><strong>as_mut_ptr</strong> : renvoie un pointeur mutable vers les éléments du vecteur.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> pointeur_mutable = vecteur.as_mut_ptr(); <span class="hljs-comment">// Récupération du pointeur mutable vers les éléments du vecteur.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le pointeur mutable du vecteur est : {:?}"</span>, pointeur_mutable); <span class="hljs-comment">// Affichage du pointeur mutable du vecteur.</span>
}
</div></code></pre>
<p><strong>Modification et Gestion des Éléments</strong></p>
<ul>
<li><strong>swap</strong> : échange les éléments à deux index spécifiés. Cette méthode est utile pour permuter les éléments d'un vecteur.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    vecteur.swap(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// Échange des éléments aux index 1 et 3.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, vecteur); <span class="hljs-comment">// Affichage du vecteur.</span>
}
</div></code></pre>
<ul>
<li><strong>retain</strong> : conserve uniquement les éléments qui satisfont le prédicat spécifié. Cela permet de filtrer les éléments d'un vecteur en fonction d'un prédicat.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    vecteur.retain(|&amp;x| x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>); <span class="hljs-comment">// Conservation des éléments pairs.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, vecteur); <span class="hljs-comment">// Affichage du vecteur.</span>
}
</div></code></pre>
<ul>
<li><strong>drain_filter</strong> : supprime et renvoie un itérateur sur les éléments du vecteur qui satisfont le prédicat spécifié.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> iterateur = vecteur.drain_filter(|&amp;x| x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>); <span class="hljs-comment">// Suppression des éléments pairs.</span>

    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> iterateur { <span class="hljs-comment">// Pour chaque élément de l'itérateur...</span>
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"L'élément supprimé est : {}"</span>, element); <span class="hljs-comment">// Affichage de la valeur de l'élément supprimé.</span>
    }
}
</div></code></pre>
<p><strong>Division et Filtrage</strong></p>
<ul>
<li><strong>split</strong> : divise le vecteur en deux à l'index spécifié.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> (gauche, droite) = vecteur.split_at(<span class="hljs-number">3</span>); <span class="hljs-comment">// Division du vecteur en deux à l'index 3.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, gauche); <span class="hljs-comment">// Affichage de la partie gauche du vecteur.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, droite); <span class="hljs-comment">// Affichage de la partie droite du vecteur.</span>
}
</div></code></pre>
<ul>
<li><strong>split_at</strong> : divise le vecteur en deux à l'index spécifié.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> (gauche, droite) = vecteur.split_at(<span class="hljs-number">3</span>); <span class="hljs-comment">// Division du vecteur en deux à l'index 3.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, gauche); <span class="hljs-comment">// Affichage de la partie gauche du vecteur.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, droite); <span class="hljs-comment">// Affichage de la partie droite du vecteur.</span>
}
</div></code></pre>
<ul>
<li><strong>partition</strong> : divise le vecteur en deux en fonction d'un prédicat.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> (pairs, impairs): (<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt;, <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt;) = vecteur.into_iter().partition(|&amp;x| x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>); <span class="hljs-comment">// Division du vecteur en deux en fonction de la parité.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, pairs); <span class="hljs-comment">// Affichage des éléments pairs du vecteur.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, impairs); <span class="hljs-comment">// Affichage des éléments impairs du vecteur.</span>
}
</div></code></pre>
<p>Voyons les détails de ce code :</p>
<ul>
<li><code>let (pairs, impairs): (Vec&lt;i32&gt;, Vec&lt;i32&gt;)</code> : déclare deux vecteurs <code>pairs</code> et <code>impairs</code> pour stocker les éléments pairs et impairs.</li>
<li><code>vecteur.into_iter().partition(|&amp;x| x % 2 == 0)</code> : divise le vecteur en deux en fonction de la parité des éléments.</li>
<li>vecteur.into_iter() : convertit le vecteur en un itérateur.</li>
<li>partition(|&amp;x| x % 2 == 0) : divise le vecteur en deux en fonction de la parité des éléments.</li>
<li><code>println!(&quot;{:?}&quot;, pairs);</code> : affiche les éléments pairs du vecteur.</li>
<li><code>println!(&quot;{:?}&quot;, impairs);</code> : affiche les éléments impairs du vecteur.</li>
</ul>
<p><strong>Aggrégation et Transformation</strong></p>
<ul>
<li><strong>join</strong> : concatène les éléments du vecteur avec une chaîne séparatrice. (Note : Cette méthode n'est pas directement disponible sur Vec<T> en Rust, mais vous pouvez l'utiliser sur des slices ou en utilisant des méthodes de l'itérateur avec des vecteurs de chaînes.)</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">"un"</span>, <span class="hljs-string">"deux"</span>, <span class="hljs-string">"trois"</span>, <span class="hljs-string">"quatre"</span>, <span class="hljs-string">"cinq"</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> chaine = vecteur.join(<span class="hljs-string">", "</span>); <span class="hljs-comment">// Concaténation des éléments du vecteur avec une chaîne séparatrice.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le vecteur concaténé est : {}"</span>, chaine); <span class="hljs-comment">// Affichage du vecteur concaténé.</span>
}
</div></code></pre>
<ul>
<li><strong>count</strong> : compte le nombre d'éléments qui satisfont le prédicat spécifié.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> nombre_pairs = vecteur.iter().filter(|&amp;x| x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).count(); <span class="hljs-comment">// Comptage des éléments pairs.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le nombre d'éléments pairs est : {}"</span>, nombre_pairs); <span class="hljs-comment">// Affichage du nombre d'éléments pairs.</span>
}
</div></code></pre>
<p><strong>Inspection et État de la Collection</strong></p>
<ul>
<li><strong>is_empty</strong> : renvoie vrai si le vecteur est vide, sinon faux.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> vecteur = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// Création d'un vecteur avec des valeurs.</span>
    <span class="hljs-keyword">let</span> est_vide = vecteur.is_empty(); <span class="hljs-comment">// Vérification si le vecteur est vide.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Le vecteur est vide : {}"</span>, est_vide); <span class="hljs-comment">// Affichage si le vecteur est vide ou non.</span>
}
</div></code></pre>
<p>Voyons les détails de ce code :</p>
<ul>
<li><code>|&amp;x|</code> : est une fermeture qui prend un élément du vecteur.</li>
<li><code>|&amp;x| x % 2 == 0</code> : est une fermeture qui conserve uniquement les éléments pairs.</li>
<li><code>retain</code> : est une méthode qui conserve uniquement les éléments qui satisfont le prédicat spécifié.</li>
<li><code>println!(&quot;{:?}&quot;, vecteur);</code> : affiche le vecteur après avoir conservé uniquement les éléments pairs.</li>
</ul>
<p>Vous pouvez découvrir d'autres méthodes de manipulation des vecteurs dans la documentation officielle de Rust à cette adresse : <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">https://doc.rust-lang.org/std/vec/struct.Vec.html</a></p>
<h1 id="entr%C3%A9es-utilisateur-et-manipulation-de-cha%C3%AEnes-de-caract%C3%A8res">Entrées utilisateur et Manipulation de Chaînes de Caractères</h1>
<h2 id="entr%C3%A9es-utilisateur">Entrées utilisateur</h2>
<h3 id="lecture-dentr%C3%A9es-utilisateur-avec-stdio">Lecture d'entrées utilisateur avec <code>std::io</code></h3>
<p>std::io est un module standard de Rust qui fournit des fonctionnalités pour la lecture et l'écriture de données à partir de la console, de fichiers et d'autres sources d'entrée/sortie. Il est couramment utilisé pour interagir avec l'utilisateur en lisant des entrées à partir de la console.</p>
<h4 id="lecture-dune-cha%C3%AEne-de-caract%C3%A8res">Lecture d'une chaîne de caractères</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> std::io;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Entrez votre nom :"</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> nom = <span class="hljs-built_in">String</span>::new(); <span class="hljs-comment">// Création d'une nouvelle chaîne pour stocker le nom.</span>
    io::stdin().read_line(&amp;<span class="hljs-keyword">mut</span> nom).expect(<span class="hljs-string">"Échec de la lecture de l'entrée"</span>); <span class="hljs-comment">// Lecture du nom de l'utilisateur.</span>

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Bonjour, {}"</span>, nom); <span class="hljs-comment">// Affichage du nom de l'utilisateur.</span>
}
</div></code></pre>
<p>Voyons les détails de ce code :</p>
<ul>
<li><code>let mut nom = String::new();</code> : crée une nouvelle chaîne vide pour stocker le nom de l'utilisateur.</li>
<li><code>io::stdin()</code> : renvoie un gestionnaire d'entrée pour la console.</li>
<li><code>read_line()</code> : lit une ligne d'entrée à partir de la console et stocke le résultat dans la chaîne <code>nom</code>.</li>
<li><code>expect();</code> : gère les erreurs de lecture de l'entrée et affiche un message d'erreur en cas d'échec.</li>
<li><code>io::stdin().read_line(&amp;mut nom).expect(&quot;Échec de la lecture de l'entrée&quot;);</code> : lit une ligne d'entrée à partir de la console et stocke le résultat dans la chaîne <code>nom</code>.</li>
<li><code>println!(&quot;Bonjour, {}&quot;, nom);</code> : affiche le nom de l'utilisateur.</li>
</ul>
<h3 id="exemple--programme-manipulant-des-donn%C3%A9es-utilisateur">Exemple : Programme manipulant des données utilisateur</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> std::io;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> noms = <span class="hljs-built_in">Vec</span>::new(); <span class="hljs-comment">// Création d'un vecteur pour stocker les noms.</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> age = <span class="hljs-built_in">Vec</span>::new(); <span class="hljs-comment">// Création d'un vecteur pour stocker les âges.</span>

    <span class="hljs-keyword">loop</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Entrez le nom de l'utilisateur (ou 'fin' pour terminer) :"</span>);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> nom = <span class="hljs-built_in">String</span>::new(); <span class="hljs-comment">// Création d'une nouvelle chaîne pour stocker le nom.</span>
        io::stdin().read_line(&amp;<span class="hljs-keyword">mut</span> nom).expect(<span class="hljs-string">"Échec de la lecture de l'entrée"</span>); <span class="hljs-comment">// Lecture du nom de l'utilisateur.</span>

        <span class="hljs-keyword">if</span> nom.trim() == <span class="hljs-string">"fin"</span> { <span class="hljs-comment">// Vérification si l'utilisateur a entré "fin".</span>
            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// Sortie de la boucle si l'utilisateur a entré "fin".</span>
        }

        noms.push(nom.trim().to_string()); <span class="hljs-comment">// Ajout du nom à la liste des noms.</span>

        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Entrez l'âge de l'utilisateur :"</span>);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> age_utilisateur = <span class="hljs-built_in">String</span>::new(); <span class="hljs-comment">// Création d'une nouvelle chaîne pour stocker l'âge.</span>
        io::stdin().read_line(&amp;<span class="hljs-keyword">mut</span> age_utilisateur).expect(<span class="hljs-string">"Échec de la lecture de l'entrée"</span>); <span class="hljs-comment">// Lecture de l'âge de l'utilisateur.</span>

        <span class="hljs-keyword">let</span> age_utilisateur: <span class="hljs-built_in">u32</span> = <span class="hljs-keyword">match</span> age_utilisateur.trim().parse() { <span class="hljs-comment">// Conversion de l'âge en nombre entier non signé.</span>
            <span class="hljs-literal">Ok</span>(valeur) =&gt; valeur, <span class="hljs-comment">// Récupération de la valeur si la conversion réussit.</span>
            <span class="hljs-literal">Err</span>(_) =&gt; {
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Veuillez entrer un nombre valide."</span>); <span class="hljs-comment">// Affichage d'un message d'erreur si la conversion échoue.</span>
                <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// Retour au début de la boucle.</span>
            }
        };

        age.push(age_utilisateur); <span class="hljs-comment">// Ajout de l'âge à la liste des âges.</span>
    }

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Les noms des utilisateurs sont : {:?}"</span>, noms); <span class="hljs-comment">// Affichage des noms des utilisateurs.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Les âges des utilisateurs sont : {:?}"</span>, age); <span class="hljs-comment">// Affichage des âges des utilisateurs.</span>
}
</div></code></pre>
<h2 id="gestion-de-projets-avec-cargo">Gestion de projets avec Cargo</h2>
<p>Cargo est l'outil de gestion de paquets et de construction de projets de Rust. Il est utilisé pour créer, construire, tester et publier des projets Rust, ainsi que pour gérer les dépendances et les bibliothèques externes. Cargo facilite le développement de projets Rust en automatisant de nombreuses tâches courantes, telles que la gestion des dépendances, la compilation du code, l'exécution des tests et la génération de la documentation.</p>
<h3 id="cr%C3%A9ation-dun-nouveau-projet">Création d'un nouveau projet</h3>
<p>Pour créer un nouveau projet Rust avec Cargo, vous pouvez utiliser la commande <code>cargo new</code> suivie du nom du projet. Par exemple, pour créer un projet nommé <code>mon_projet</code>, vous pouvez exécuter la commande suivante dans votre terminal :</p>
<pre class="hljs"><code><div>cargo new mon_projet
</div></code></pre>
<p>Cette commande crée un nouveau répertoire nommé <code>mon_projet</code> contenant les fichiers et répertoires suivants :</p>
<pre class="hljs"><code><div>mon_projet
├── Cargo.toml
└── src
    └── main.rs
</div></code></pre>
<h3 id="d%C3%A9pendances-et-crates">Dépendances et Crates</h3>
<p>En Rust, les bibliothèques et les paquets sont appelés des &quot;crates&quot;. Les dépendances externes sont spécifiées dans le fichier <code>Cargo.toml</code> à la racine du projet. Voici un exemple de fichier <code>Cargo.toml</code> avec des dépendances spécifiées :</p>
<pre class="hljs"><code><div><span class="hljs-section">[package]</span>
<span class="hljs-attr">name</span> = <span class="hljs-string">"mon_projet"</span>
<span class="hljs-attr">version</span> = <span class="hljs-string">"0.1.0"</span>
<span class="hljs-attr">edition</span> = <span class="hljs-string">"2018"</span>

<span class="hljs-section">[dependencies]</span>
<span class="hljs-attr">rand</span> = <span class="hljs-string">"0.8.4"</span>
</div></code></pre>
<p>Dans cet exemple, la section <code>[dependencies]</code> spécifie les dépendances du projet. La dépendance <code>rand</code> est spécifiée avec la version <code>0.8.4</code>. Lorsque vous exécutez <code>cargo build</code> ou <code>cargo run</code>, Cargo télécharge et installe automatiquement les dépendances spécifiées à partir du registre de crates de Rust.</p>
<h3 id="tests">Tests</h3>
<p>Les tests unitaires peuvent être écrits dans le fichier <code>src/main.rs</code> ou dans des fichiers séparés dans le répertoire <code>tests</code>. Voici un exemple de test unitaire dans le fichier <code>src/main.rs</code> :</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">somme</span></span>(a: <span class="hljs-built_in">i32</span>, b: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> {
    a + b
}

<span class="hljs-meta">#[cfg(test)]</span>

<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_somme</span></span>() {
        <span class="hljs-built_in">assert_eq!</span>(somme(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), <span class="hljs-number">4</span>);
        <span class="hljs-built_in">assert_eq!</span>(somme(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), <span class="hljs-number">4</span>);
        <span class="hljs-built_in">assert_eq!</span>(somme(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-number">0</span>);
    }
}
</div></code></pre>
<p>Dans cet exemple, la fonction <code>somme</code> est testée avec plusieurs cas de test à l'aide de la macro <code>#[test]</code>. Lorsque vous exécutez <code>cargo test</code>, Cargo exécute les tests unitaires et affiche les résultats.</p>
<h3 id="documentation">Documentation</h3>
<p>La documentation du projet peut être générée à l'aide de la commande <code>cargo doc</code>. Cette commande génère la documentation du projet à partir des commentaires de documentation (doc comments) dans le code source. La documentation générée est stockée dans le répertoire <code>target/doc</code> et peut être consultée en ouvrant le fichier <code>index.html</code> dans un navigateur web.</p>
<h3 id="exemple--cr%C3%A9ation-dun-projet-avec-d%C3%A9pendances-externes">Exemple : Création d'un projet avec dépendances externes</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> rand::Rng;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> nombre_secret = rand::thread_rng().gen_range(<span class="hljs-number">1</span>..<span class="hljs-number">101</span>);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Devinez le nombre secret entre 1 et 100."</span>);

    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> supposition = <span class="hljs-built_in">String</span>::new();
        std::io::stdin().read_line(&amp;<span class="hljs-keyword">mut</span> supposition).expect(<span class="hljs-string">"Échec de la lecture de l'entrée"</span>);
        <span class="hljs-keyword">let</span> supposition: <span class="hljs-built_in">u32</span> = <span class="hljs-keyword">match</span> supposition.trim().parse() {
            <span class="hljs-literal">Ok</span>(valeur) =&gt; valeur,
            <span class="hljs-literal">Err</span>(_) =&gt; {
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Veuillez entrer un nombre valide."</span>);
                <span class="hljs-keyword">continue</span>;
            }
        };

        <span class="hljs-keyword">match</span> supposition.cmp(&amp;nombre_secret) {
            std::cmp::Ordering::Less =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Trop petit !"</span>),
            std::cmp::Ordering::Greater =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Trop grand !"</span>),
            std::cmp::Ordering::Equal =&gt; {
                <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Bravo, vous avez deviné le nombre secret !"</span>);
                <span class="hljs-keyword">break</span>;
            }
        }
    }
}
</div></code></pre>
<p>Analysons ce code en détail :</p>
<ul>
<li><code>use rand::Rng;</code> : importe le trait <code>Rng</code> du crate <code>rand</code> pour générer un nombre aléatoire.</li>
<li><code>let nombre_secret = rand::thread_rng().gen_range(1..101);</code> : génère un nombre aléatoire entre 1 et 100 à l'aide de la méthode <code>gen_range</code> du générateur de nombres aléatoires <code>thread_rng</code>.</li>
<li><code>std::io::stdin().read_line(&amp;mut supposition).expect(&quot;Échec de la lecture de l'entrée&quot;);</code> : lit une ligne d'entrée à partir de la console et stocke le résultat dans la chaîne <code>supposition</code>.</li>
<li><code>match supposition.cmp(&amp;nombre_secret)</code> : compare la supposition de l'utilisateur avec le nombre secret et affiche un message en fonction du résultat de la comparaison.</li>
<li><code>std::cmp::Ordering::Less</code> : indique que la supposition est inférieure au nombre secret.</li>
<li><code>std::cmp::Ordering::Greater</code> : indique que la supposition est supérieure au nombre secret.</li>
<li><code>std::cmp::Ordering::Equal</code> : indique que la supposition est égale au nombre secret.</li>
<li><code>continue;</code> : passe à l'itération suivante de la boucle.</li>
<li><code>break;</code> : sort de la boucle.</li>
</ul>
<p>Dans cet exemple, le projet utilise la dépendance externe <code>rand</code> pour générer un nombre aléatoire. La dépendance <code>rand</code> est spécifiée dans le fichier <code>Cargo.toml</code> comme suit :</p>
<pre class="hljs"><code><div><span class="hljs-section">[dependencies]</span>
<span class="hljs-attr">rand</span> = <span class="hljs-string">"0.8.4"</span>
</div></code></pre>
<h3 id="construction-et-ex%C3%A9cution-du-projet">Construction et Exécution du Projet</h3>
<p>Pour construire et exécuter un projet Rust avec Cargo, vous pouvez utiliser les commandes suivantes :</p>
<ul>
<li><code>cargo build</code> : compile le projet et génère un exécutable dans le répertoire <code>target/debug</code>.</li>
<li><code>cargo run</code> : compile et exécute le projet.</li>
<li><code>cargo test</code> : exécute les tests unitaires du projet.</li>
<li><code>cargo doc</code> : génère la documentation du projet.</li>
<li><code>cargo clean</code> : supprime les fichiers générés par Cargo.</li>
<li><code>cargo update</code> : met à jour les dépendances du projet.</li>
<li><code>cargo check</code> : vérifie la validité du code sans le compiler.</li>
<li><code>cargo fmt</code> : formate le code selon les conventions de style de Rust.</li>
<li><code>cargo clippy</code> : exécute l'analyseur statique de code Clippy pour détecter les erreurs et les problèmes de style.</li>
<li><code>cargo install</code> : installe un exécutable Rust à partir d'un crate.</li>
<li><code>cargo publish</code> : publie un crate sur le registre de crates de Rust.</li>
<li><code>cargo search</code> : recherche un crate sur le registre de crates de Rust.</li>
<li><code>cargo new</code> : crée un nouveau projet Rust.</li>
<li><code>cargo init</code> : initialise un nouveau projet Rust dans un répertoire existant.</li>
</ul>
<h2 id="programmation-concurrente-et-parall%C3%A9lisme">Programmation concurrente et Parallélisme</h2>
<p>La programmation concurrente et le parallélisme sont des concepts fondamentaux pour améliorer l'efficacité et la performance des applications modernes. Rust offre un excellent soutien pour ces paradigmes à travers plusieurs abstractions. Voici un aperçu des concepts et un exemple de leur utilisation.</p>
<h3 id="threads">Threads</h3>
<p>Les threads permettent à votre programme d'exécuter plusieurs tâches simultanément. Rust fournit une abstraction pour travailler avec des threads de manière à éviter de nombreux problèmes courants, comme les conditions de course ou les deadlocks.</p>
<h4 id="cr%C3%A9ation-de-threads">Création de Threads</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> std::thread;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> handle = thread::spawn(|| { <span class="hljs-comment">// Création d'un nouveau thread.</span>
        <span class="hljs-comment">// Code exécuté dans un nouveau thread.</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..=<span class="hljs-number">5</span> { <span class="hljs-comment">// Pour chaque nombre de 1 à 5...</span>
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Nouveau thread : {}"</span>, i);
            thread::sleep(std::time::Duration::from_millis(<span class="hljs-number">500</span>)); <span class="hljs-comment">// Mise en sommeil du thread.</span>
        }
    });

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..=<span class="hljs-number">3</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Thread principal : {}"</span>, i);
        thread::sleep(std::time::Duration::from_millis(<span class="hljs-number">1000</span>)); <span class="hljs-comment">// Mise en sommeil du thread principal.</span>
    }

    handle.join().unwrap(); <span class="hljs-comment">// Attente de la fin du thread.</span>
}
</div></code></pre>
<p>Analysons ce code en détail :</p>
<ul>
<li><code>let handle = thread::spawn(|| { ... });</code> : crée un nouveau thread et exécute le code spécifié dans la fermeture.</li>
<li><code>thread::sleep(std::time::Duration::from_millis(500));</code> : met le thread en sommeil pendant 500 millisecondes.</li>
<li><code>handle.join().unwrap();</code> : attend la fin du thread et récupère le résultat.</li>
<li><code>thread::sleep(std::time::Duration::from_millis(1000));</code> : met le thread principal en sommeil pendant 1000 millisecondes.</li>
<li><code>println!(&quot;Nouveau thread : {}&quot;, i);</code> : affiche le numéro de l'itération dans le nouveau thread.</li>
<li><code>println!(&quot;Thread principal : {}&quot;, i);</code> : affiche le numéro de l'itération dans le thread principal.</li>
<li><code>for i in 1..=5 { ... }</code> : exécute une boucle dans le nouveau thread. de 1 à 5.</li>
</ul>
<h3 id="canaux-de-communication">Canaux de communication</h3>
<p>Les canaux de communication permettent à différents threads d'échanger des données de manière asynchrone. Rust fournit une abstraction pour travailler avec des canaux de manière à éviter de nombreux problèmes courants, comme les conditions de course ou les deadlocks.</p>
<p>Rust propose des canaux (channels) pour la communication entre threads. Un canal a deux extrémités : un émetteur (sender) et un récepteur (receiver).</p>
<h4 id="cr%C3%A9ation-dun-canal">Création d'un canal</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> std::sync::mpsc;
<span class="hljs-keyword">use</span> std::thread;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> (emetteur, recepteur) = mpsc::channel(); <span class="hljs-comment">// Création d'un canal pour la communication entre threads.</span>

    thread::spawn(<span class="hljs-keyword">move</span> || { <span class="hljs-comment">// Création d'un nouveau thread.</span>
        <span class="hljs-keyword">let</span> message = <span class="hljs-string">"Bonjour depuis le thread émetteur !"</span>.to_string();
        emetteur.send(message).unwrap(); <span class="hljs-comment">// Envoi d'un message à travers le canal.</span>
    });

    <span class="hljs-keyword">let</span> message_recu = recepteur.recv().unwrap(); <span class="hljs-comment">// Réception du message à travers le canal.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Message reçu : {}"</span>, message_recu); <span class="hljs-comment">// Affichage du message reçu.</span>
}
</div></code></pre>
<p>Analysons ce code en détail :</p>
<ul>
<li><code>let (emetteur, recepteur) = mpsc::channel();</code> : crée un canal pour la communication entre threads.</li>
<li><code>thread::spawn(move || { ... });</code> : crée un nouveau thread et exécute le code spécifié dans la fermeture.</li>
<li><code>emetteur.send(message).unwrap();</code> : envoie un message à travers le canal.</li>
<li><code>let message_recu = recepteur.recv().unwrap();</code> : reçoit un message à travers le canal.</li>
<li><code>println!(&quot;Message reçu : {}&quot;, message_recu);</code> : affiche le message reçu.</li>
<li><code>let message = &quot;Bonjour depuis le thread émetteur !&quot;.to_string();</code> : crée un message à envoyer à travers le canal.</li>
</ul>
<h3 id="mod%C3%A8le-de-m%C3%A9moire-partag%C3%A9e">Modèle de mémoire partagée</h3>
<p>Le modèle de mémoire partagée permet à plusieurs threads d'accéder et de modifier des données partagées de manière synchronisée. Rust fournit une abstraction pour travailler avec la mémoire partagée de manière à éviter de nombreux problèmes courants, comme les conditions de course ou les deadlocks.</p>
<p>Rust utilise le concept de propriété et d'emprunt pour éviter les problèmes dans un environnement concurrent. Les types <code>Arc</code> et <code>Mutex</code> sont souvent utilisés ensemble pour partager un état entre des threads de manière sécurisée.</p>
<h4 id="exemple--m%C3%A9moire-partag%C3%A9e-avec-mutex">Exemple : Mémoire partagée avec Mutex</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> std::sync::{Arc, Mutex};
<span class="hljs-keyword">use</span> std::thread;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> donnees_partagees = Arc::new(Mutex::new(<span class="hljs-number">0</span>)); <span class="hljs-comment">// Création d'une mémoire partagée avec Mutex.</span>

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> threads = <span class="hljs-built_in">vec!</span>[]; <span class="hljs-comment">// Création d'un vecteur pour stocker les threads.</span>

    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">5</span> {
        <span class="hljs-keyword">let</span> donnees_partagees = Arc::clone(&amp;donnees_partagees); <span class="hljs-comment">// Clonage de la mémoire partagée pour chaque thread.</span>
        <span class="hljs-keyword">let</span> thread = thread::spawn(<span class="hljs-keyword">move</span> || { <span class="hljs-comment">// Création d'un nouveau thread.</span>
            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> donnees = donnees_partagees.lock().unwrap(); <span class="hljs-comment">// Verrouillage de la mémoire partagée.</span>
            *donnees += <span class="hljs-number">1</span>; <span class="hljs-comment">// Incrémentation des données partagées.</span>
        });
        threads.push(thread); <span class="hljs-comment">// Ajout du thread au vecteur.</span>
    }

    <span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> threads {
        thread.join().unwrap(); <span class="hljs-comment">// Attente de la fin de chaque thread.</span>
    }

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Données partagées : {}"</span>, *donnees_partagees.lock().unwrap()); <span class="hljs-comment">// Affichage des données partagées.</span>
}
</div></code></pre>
<p>Analysons ce code en détail :</p>
<ul>
<li><code>let donnees_partagees = Arc::new(Mutex::new(0));</code> : crée une mémoire partagée avec Mutex.</li>
<li><code>let donnees_partagees = Arc::clone(&amp;donnees_partagees);</code> : clone la mémoire partagée pour chaque thread.</li>
<li><code>let mut donnees = donnees_partagees.lock().unwrap();</code> : verrouille la mémoire partagée.</li>
<li><code>*donnees += 1;</code> : incrémente les données partagées.</li>
<li><code>thread.join().unwrap();</code> : attend la fin de chaque thread.</li>
<li><code>println!(&quot;Données partagées : {}&quot;, *donnees_partagees.lock().unwrap());</code> : affiche les données partagées.</li>
<li><code>let mut threads = vec![];</code> : crée un vecteur pour stocker les threads.</li>
<li><code>for _ in 0..5 { ... }</code> : crée cinq threads pour incrémenter les données partagées.</li>
<li><code>let thread = thread::spawn(move || { ... });</code> : crée un nouveau thread et exécute le code spécifié dans la fermeture.</li>
<li><code>for thread in threads { ... }</code> : attend la fin de chaque thread.</li>
<li><code>let donnees_partagees = Arc::clone(&amp;donnees_partagees);</code> : clone la mémoire partagée pour chaque thread.</li>
</ul>
<h3 id="exemple--programme-t%C3%A9l%C3%A9chargeant-des-donn%C3%A9es-en-parall%C3%A8le">Exemple : Programme téléchargeant des données en parallèle</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">use</span> std::sync::{Arc, Mutex};
<span class="hljs-keyword">use</span> std::thread;
<span class="hljs-keyword">use</span> std::time::Duration;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">telecharger_donnees</span></span>(url: &amp;<span class="hljs-built_in">str</span>, donnees: Arc&lt;Mutex&lt;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">u8</span>&gt;&gt;&gt;) {
    <span class="hljs-comment">// Simulation du téléchargement de données à partir de l'URL.</span>
    thread::sleep(Duration::from_secs(<span class="hljs-number">2</span>));
    <span class="hljs-keyword">let</span> donnees_telechargees = <span class="hljs-string">b"Exemple de données téléchargées"</span>;
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> donnees = donnees.lock().unwrap();
    donnees.extend_from_slice(donnees_telechargees);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> donnees = Arc::new(Mutex::new(<span class="hljs-built_in">Vec</span>::new())); <span class="hljs-comment">// Création d'une mémoire partagée avec Mutex pour stocker les données téléchargées.</span>

    <span class="hljs-keyword">let</span> urls = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">"http://exemple.com/fichier1"</span>, <span class="hljs-string">"http://exemple.com/fichier2"</span>, <span class="hljs-string">"http://exemple.com/fichier3"</span>];

    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> threads = <span class="hljs-built_in">vec!</span>[]; <span class="hljs-comment">// Création d'un vecteur pour stocker les threads.</span>

    <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls {
        <span class="hljs-keyword">let</span> donnees = Arc::clone(&amp;donnees); <span class="hljs-comment">// Clonage de la mémoire partagée pour chaque thread.</span>
        <span class="hljs-keyword">let</span> thread = thread::spawn(<span class="hljs-keyword">move</span> || { <span class="hljs-comment">// Création d'un nouveau thread.</span>
            telecharger_donnees(url, donnees); <span class="hljs-comment">// Téléchargement des données à partir de l'URL.</span>
        });
        threads.push(thread); <span class="hljs-comment">// Ajout du thread au vecteur.</span>
    }

    <span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> threads {
        thread.join().unwrap(); <span class="hljs-comment">// Attente de la fin de chaque thread.</span>
    }

    <span class="hljs-keyword">let</span> donnees = donnees.lock().unwrap(); <span class="hljs-comment">// Verrouillage de la mémoire partagée.</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Données téléchargées : {:?}"</span>, *donnees); <span class="hljs-comment">// Affichage des données téléchargées.</span>
}
</div></code></pre>
<h1 id="projets-et-ressources-compl%C3%A9mentaires">Projets et Ressources Complémentaires</h1>
<p>Rust est un langage puissant et flexible, idéal pour une multitude de projets, allant des outils en ligne de commande aux serveurs web et aux systèmes embarqués. Voici des idées pour mettre en pratique vos connaissances en Rust, suivies de ressources pour approfondir votre apprentissage et vous connecter à la communauté.</p>
<h2 id="cr%C3%A9er-un-projet-en-rust">Créer un projet en Rust</h2>
<h3 id="id%C3%A9es-de-projets-pour-appliquer-les-connaissances-acquises">Idées de projets pour appliquer les connaissances acquises</h3>
<ol>
<li>
<p><strong>Interpréteur de Langage de Programmation</strong>: Développez un simple interpréteur pour un langage de programmation inventé ou existant. Cela peut vous aider à comprendre les principes de la compilation et de l'interprétation.</p>
</li>
<li>
<p><strong>Serveur Web</strong>: Utilisez <code>hyper</code> ou <code>actix-web</code> pour créer un serveur web performant. Commencez par servir des pages statiques avant de passer à des applications web dynamiques.</p>
</li>
<li>
<p><strong>Outils en Ligne de Commande</strong>: Créez des outils pour simplifier les tâches courantes sur votre système. Vous pourriez développer un programme pour gérer vos notes ou automatiser des tâches répétitives.</p>
</li>
<li>
<p><strong>Jeu en 2D</strong>: Avec <code>ggez</code> ou <code>piston</code>, vous pouvez créer des jeux simples pour explorer la programmation graphique et de jeu.</p>
</li>
<li>
<p><strong>Client Torrent</strong>: Implémentez un client torrent simple pour comprendre les réseaux et la communication peer-to-peer.</p>
</li>
</ol>
<h3 id="%C3%A9tapes-de-d%C3%A9veloppement-dun-projet">Étapes de développement d'un projet</h3>
<ol>
<li>
<p><strong>Conception et Planification</strong>: Définissez clairement le but de votre projet. Planifiez les fonctionnalités principales et l'interface utilisateur si nécessaire.</p>
</li>
<li>
<p><strong>Environnement de Développement</strong>: Configurez votre environnement avec Rust et les outils nécessaires (Cargo, Clippy, Rustfmt).</p>
</li>
<li>
<p><strong>Prototypage</strong>: Commencez par coder les fonctionnalités de base. Un prototype fonctionnel vous permet de tester rapidement des idées.</p>
</li>
<li>
<p><strong>Itération</strong>: Développez votre projet en ajoutant des fonctionnalités, en corrigeant des bugs et en améliorant les performances.</p>
</li>
<li>
<p><strong>Tests</strong>: Écrivez des tests unitaires et d'intégration pour assurer la fiabilité de votre code.</p>
</li>
<li>
<p><strong>Documentation</strong>: Documentez votre code et créez un README utile pour expliquer comment utiliser votre projet.</p>
</li>
<li>
<p><strong>Publication</strong>: Publiez votre code sur GitHub et partagez-le avec la communauté. Considérez la publication de votre projet sur crates.io si vous avez créé une bibliothèque.</p>
</li>
</ol>
<h2 id="ressources-compl%C3%A9mentaires-et-communaut%C3%A9">Ressources complémentaires et communauté</h2>
<h3 id="livres-et-documentation-en-ligne">Livres et documentation en ligne</h3>
<ul>
<li><strong>The Rust Programming Language</strong>: Le livre officiel de Rust, disponible gratuitement en ligne à l'adresse <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>.</li>
<li><strong>Rust by Example</strong>: Un autre livre officiel de Rust, disponible gratuitement en ligne à l'adresse <a href="https://doc.rust-lang.org/rust-by-example/">https://doc.rust-lang.org/rust-by-example/</a>.</li>
<li><strong>Rust Reference</strong>: La documentation de référence officielle de Rust, disponible gratuitement en ligne à l'adresse <a href="https://doc.rust-lang.org/reference/">https://doc.rust-lang.org/reference/</a>.</li>
<li><strong>Rustonomicon</strong>: Un livre sur les aspects sombres de Rust, disponible gratuitement en ligne à l'adresse <a href="https://doc.rust-lang.org/nomicon/">https://doc.rust-lang.org/nomicon/</a>.</li>
</ul>
<h3 id="forums-groupes-et-conf%C3%A9rences">Forums, groupes et conférences</h3>
<ul>
<li><strong>Rust Users Forum</strong>: Un forum de discussion pour les utilisateurs de Rust, disponible à l'adresse <a href="https://users.rust-lang.org/">https://users.rust-lang.org/</a>.</li>
<li><strong>Rust Subreddit</strong>: Un subreddit dédié à Rust, disponible à l'adresse <a href="https://www.reddit.com/r/rust/">https://www.reddit.com/r/rust/</a>.</li>
<li><strong>Rust Discord</strong>: Un serveur Discord pour discuter de Rust, disponible à l'adresse <a href="https://discord.gg/rust-lang">https://discord.gg/rust-lang</a>.</li>
</ul>
<h3 id="outils-et-biblioth%C3%A8ques">Outils et bibliothèques</h3>
<ul>
<li><strong>Crates.io</strong>: Le registre de crates de Rust, disponible à l'adresse <a href="https://crates.io/">https://crates.io/</a>.</li>
<li><strong>Rustup</strong>: Un outil pour gérer les versions de Rust et les outils associés, disponible à l'adresse <a href="https://rustup.rs/">https://rustup.rs/</a>.</li>
<li><strong>Clippy</strong>: Un linter pour Rust, disponible à l'adresse <a href="https://doc.rust-lang.org/clippy/">https://doc.rust-lang.org/clippy/</a>.</li>
<li><strong>Rustfmt</strong>: Un formateur de code pour Rust, disponible à l'adresse <a href="https://doc.rust-lang.org/beta/nightly-rustc/rustfmt/index.html">https://doc.rust-lang.org/beta/nightly-rustc/rustfmt/index.html</a>.</li>
<li><strong>Rust Analyzer</strong>: Un analyseur de code pour Rust, disponible à l'adresse <a href="https://rust-analyzer.github.io/">https://rust-analyzer.github.io/</a>.</li>
</ul>
<h1 id="conclusion">Conclusion</h1>
<p>Ce guide a couvert les bases de la programmation en Rust, y compris les types de données, les structures de contrôle, les fonctions, les modules, les collections, les entrées utilisateur, la manipulation de chaînes de caractères, la gestion de projets avec Cargo, la programmation concurrente et le parallélisme. Nous avons également exploré des idées de projets et des ressources pour approfondir votre apprentissage et vous connecter à la communauté.</p>
<h2 id="r%C3%A9vision-et-prochaines-%C3%A9tapes">Révision et prochaines étapes</h2>
<h3 id="r%C3%A9capitulatif-des-concepts-cl%C3%A9s">Récapitulatif des concepts clés</h3>
<ul>
<li><strong>Types de données et variables</strong>: Rust offre une variété de types de données, y compris les types primitifs, les types composés et les types personnalisés.</li>
<li><strong>Structures de contrôle</strong>: Les structures de contrôle, telles que les boucles et les instructions conditionnelles, permettent de contrôler le flux d'exécution du programme.</li>
<li><strong>Fonctions et modules</strong>: Les fonctions et les modules permettent d'organiser et de réutiliser le code de manière efficace.</li>
<li><strong>Collections</strong>: Les collections, telles que les vecteurs et les chaînes de caractères, offrent des moyens flexibles de stocker et de manipuler des données.</li>
<li><strong>Entrées utilisateur et manipulation de chaînes de caractères</strong>: La bibliothèque standard de Rust offre des fonctionnalités pour lire des entrées utilisateur et manipuler des chaînes de caractères.</li>
<li><strong>Gestion de projets avec Cargo</strong>: Cargo est l'outil de gestion de paquets et de construction de projets de Rust, qui facilite le développement de projets Rust en automatisant de nombreuses tâches courantes.</li>
<li><strong>Programmation concurrente et parallélisme</strong>: Rust offre un excellent soutien pour la programmation concurrente et le parallélisme à travers plusieurs abstractions, telles que les threads, les canaux de communication et la mémoire partagée.</li>
<li><strong>Projets et ressources complémentaires</strong>: Vous pouvez appliquer vos connaissances en Rust en créant des projets et en explorant les ressources disponibles pour approfondir votre apprentissage et vous connecter à la communauté.</li>
</ul>
<h3 id="prochaines-%C3%A9tapes">Prochaines étapes</h3>
<ul>
<li><strong>Créez un projet en Rust</strong>: Utilisez les idées de projets pour créer un projet en Rust et appliquer vos connaissances.</li>
<li><strong>Explorez les ressources complémentaires</strong>: Utilisez les livres, la documentation en ligne, les forums, les groupes et les conférences pour approfondir votre apprentissage et vous connecter à la communauté.</li>
<li><strong>Partagez votre travail</strong>: Publiez votre projet sur GitHub, partagez-le avec la communauté et contribuez à l'écosystème de Rust.</li>
<li><strong>Continuez à apprendre et à pratiquer</strong>: La programmation en Rust est un voyage continu. Continuez à explorer de nouveaux concepts, à résoudre des problèmes et à développer des projets pour renforcer vos compétences.</li>
</ul>
<h3 id="conseils-pour-continuer-%C3%A0-apprendre-et-pratiquer">Conseils pour continuer à apprendre et pratiquer</h3>
<ul>
<li><strong>Explorez des projets open source</strong>: Contribuez à des projets open source en Rust pour acquérir de l'expérience pratique et apprendre des meilleures pratiques.</li>
<li><strong>Participez à des événements et des hackathons</strong>: Rejoignez des événements et des hackathons pour rencontrer d'autres développeurs, apprendre de nouvelles techniques et développer des projets en équipe.</li>
<li><strong>Créez des projets personnels</strong>: Trouvez des problèmes intéressants à résoudre et créez des projets personnels pour explorer de nouveaux concepts et technologies.</li>
<li><strong>Enseignez et partagez vos connaissances</strong>: Enseignez aux autres ce que vous avez appris en écrivant des articles, en donnant des présentations ou en aidant les autres développeurs.</li>
<li><strong>Restez curieux et ouvert d'esprit</strong>: La programmation en Rust est un domaine en constante évolution. Restez curieux, ouvert d'esprit et prêt à apprendre de nouvelles choses.</li>
<li>Vous pouver utiliser le playground de Rust pour tester vos codes en ligne : <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a></li>
</ul>
<h3 id="remerciements-et-ressources">Remerciements et ressources</h3>
<p>Merci d'avoir suivi ce guide sur la programmation en Rust. Pour en savoir plus sur Rust, consultez les ressources suivantes :</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/">Rust by Example</a>****</li>
</ul>

</body>
</html>
